<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elder Heliosystem Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            color: #eee;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }
        
        button {
            background-color: #4a5eff;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #6a7eff;
        }
        
        .entity-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        h2 {
            margin-top: 0;
            color: #6a7eff;
        }
        
        .phase-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }
        
        .parameter-activation {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            z-index: 100;
        }
        
        .highlight {
            color: #ffcc00;
            font-weight: bold;
        }
        
        .syzygy-monitor {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        .syzygy-inactive {
            color: #555555;
            font-size: 24px;
            text-align: center;
            margin-top: 5px;
        }
        
        .syzygy-active {
            color: #ff00ff;
            font-size: 24px;
            text-align: center;
            margin-top: 5px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1.0; transform: scale(1.2); }
            100% { opacity: 0.3; transform: scale(0.8); }
        }
        
        .syzygy-line {
            stroke: rgba(255, 0, 255, 0.6);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            animation: dash 1s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }
        
        .entity-controls {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .entity-controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #6a7eff;
        }
        
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        select {
            background-color: #2a2a4a;
            color: white;
            border: none;
            padding: 5px;
            border-radius: 5px;
        }
        
        .entity-fade-in {
            animation: fadeIn 0.8s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>Elder Heliosystem</h2>
            <button id="play-pause">Pause</button>
            <button id="reset">Reset</button>
            <div>
                <label for="speed">Simulation Speed:</label>
                <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="entity-controls">
                <h3>Entity Management</h3>
                <div class="control-group">
                    <button id="add-mentor">Add Mentor</button>
                    <select id="mentor-domain">
                        <option value="random">Random Domain</option>
                        <option value="Audio Processing">Audio Processing</option>
                        <option value="Visual Analysis">Visual Analysis</option>
                        <option value="Semantic Understanding">Semantic Understanding</option>
                        <option value="Spatial Relations">Spatial Relations</option>
                        <option value="Multimodal Fusion">Multimodal Fusion</option>
                    </select>
                </div>
                <div class="control-group">
                    <button id="add-erudite">Add Erudite</button>
                    <select id="mentor-select">
                        <option value="random">Random Mentor</option>
                    </select>
                </div>
                <div>
                    <span>Mentors: <span id="mentor-count">0</span></span> | 
                    <span>Erudites: <span id="erudite-count">0</span></span>
                </div>
            </div>
        </div>
        
        <div class="entity-info">
            <h2>Entity Information</h2>
            <p>Hover over an entity to see details</p>
            <div id="entity-details"></div>
        </div>
        
        <div class="phase-indicator">
            <h2>Elder Phase: <span id="current-phase">0.00</span></h2>
            <div id="phase-circle" style="width: 40px; height: 40px; border-radius: 50%; background-color: hsl(210, 100%, 50%); margin: 10px auto;"></div>
        </div>
        
        <div class="parameter-activation">
            <h2>Parameter Activation</h2>
            <div>Active Parameters: <span id="active-count" class="highlight">0</span> / <span id="total-count">1,200,000,000</span></div>
            <div>Memory Usage: <span id="memory-usage" class="highlight">121.34</span> MB</div>
            <div>System-Determined Sparsity: <span id="sparsity-factor" class="highlight">0.0001</span>%</div>
            <div id="activation-graph" style="height: 60px; margin-top: 10px;"></div>
        </div>
        
        <div class="syzygy-monitor">
            <h2>Syzygy Alignment</h2>
            <div>Active Syzygies: <span id="syzygy-count" class="highlight">0</span></div>
            <div>Latest: <span id="syzygy-latest" class="highlight">None</span></div>
            <div>Parameter Efficiency: <span id="syzygy-efficiency" class="highlight">1.0</span>×</div>
            <div id="syzygy-indicator" class="syzygy-inactive">●</div>
        </div>
        
        <svg id="visualization"></svg>
        
        <div class="tooltip" style="display: none;"></div>
    </div>

    <script>
        // Configuration
        const config = {
            elder: {
                count: 1,
                radius: 30,
                color: "#ff5500",
                orbitRadius: 0
            },
            mentors: {
                count: 32,
                radius: 12,
                colors: d3.scaleSequential(d3.interpolateRainbow),
                orbitRadius: 200
            },
            erudites: {
                count: 128, // Showing a subset for visualization performance
                radius: 4,
                colors: d3.scaleSequential(d3.interpolateCool),
                orbitRadiusMin: 40,
                orbitRadiusMax: 80
            },
            phases: {
                initElderPhase: 0,
                elderPhaseVelocity: 0.005,
                mentorPhaseOffset: Math.PI / 16,
                eruditePhaseOffset: Math.PI / 32
            },
            parameters: {
                totalCount: 1200000000,
                peakMemoryMB: 121.34,
                // Sparsity calculation parameters
                sparsityBase: 0.0001, // Base sparsity factor
                phaseToleranceBase: 0.025, // Base phase tolerance
                adaptiveFactors: true, // Whether sparsity adapts to system state
                // Syzygy configuration
                syzygyDetection: true, // Whether to detect syzygy alignments
                syzygyAngleTolerance: 0.05, // Angular tolerance in radians for syzygy detection
                syzygyBoostFactor: 5.0 // How much to boost parameter efficiency during syzygy
            }
        };
        
        // Simulation state
        let simulationState = {
            running: true,
            speed: 1,
            elderPhase: config.phases.initElderPhase,
            entities: [],
            activeParameters: 0,
            activationHistory: Array(100).fill(0),
            selectedEntity: null,
            // Syzygy tracking
            activeSyzygies: [], // Array of current syzygy triplets (Elder-Mentor-Erudite)
            syzygyCounts: {}, // Counts of syzygies by Mentor-Erudite pair
            syzygyHistory: [], // Array of recent syzygy events
            lastSyzygyTime: 0 // Time of last syzygy event
        };
        
        // Initialize the visualization
        function init() {
            const svg = d3.select("#visualization");
            const container = document.querySelector(".container");
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Update parameter display
            document.getElementById("total-count").textContent = config.parameters.totalCount.toLocaleString();
            document.getElementById("sparsity-factor").textContent = (config.parameters.sparsityBase * 100).toFixed(6);
            
            // Create a group for syzygy lines
            svg.append("g").attr("class", "syzygy-lines");
            
            svg.attr("width", width)
                .attr("height", height);
            
            // Create starfield background
            const starCount = 500;
            const stars = [];
            
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: Math.random() * 1.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
            
            svg.selectAll(".star")
                .data(stars)
                .enter()
                .append("circle")
                .attr("class", "star")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => d.radius)
                .attr("fill", "#ffffff")
                .attr("opacity", d => d.opacity);
                
            // Create orbit paths
            const center = { x: width / 2, y: height / 2 };
            
            // Mentor orbit
            svg.append("circle")
                .attr("cx", center.x)
                .attr("cy", center.y)
                .attr("r", config.mentors.orbitRadius)
                .attr("fill", "none")
                .attr("stroke", "#334466")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3");
                
            // Create entities
            createEntities(center);
            
            // Create parameters activation visualization
            createActivationGraph();
            
            // Set up event listeners
            document.getElementById("play-pause").addEventListener("click", toggleSimulation);
            document.getElementById("reset").addEventListener("click", resetSimulation);
            document.getElementById("speed").addEventListener("input", updateSpeed);
            
            // Start animation loop
            requestAnimationFrame(animate);
        }
        
        function createEntities(center) {
            const svg = d3.select("#visualization");
            simulationState.entities = [];
            
            // Create Elder
            const elder = {
                id: "elder-0",
                type: "elder",
                x: center.x,
                y: center.y,
                radius: config.elder.radius,
                color: config.elder.color,
                phase: config.phases.initElderPhase,
                phaseVelocity: config.phases.elderPhaseVelocity,
                orbitRadius: 0,
                orbitCenter: { x: center.x, y: center.y },
                parent: null,
                domain: "Global",
                description: "Central entity governing the entire system through phase coordination"
            };
            
            simulationState.entities.push(elder);
            
            // Create Mentors
            for (let i = 0; i < config.mentors.count; i++) {
                const angle = (i / config.mentors.count) * Math.PI * 2;
                const orbitRadius = config.mentors.orbitRadius;
                const domain = getMentorDomain(i);
                
                const mentor = {
                    id: `mentor-${i}`,
                    type: "mentor",
                    orbitRadius: orbitRadius,
                    orbitCenter: { x: center.x, y: center.y },
                    radius: config.mentors.radius,
                    color: config.mentors.colors(i / config.mentors.count),
                    phase: config.phases.initElderPhase + i * config.phases.mentorPhaseOffset,
                    phaseVelocity: config.phases.elderPhaseVelocity * (0.8 + Math.random() * 0.4),
                    x: center.x + orbitRadius * Math.cos(angle),
                    y: center.y + orbitRadius * Math.sin(angle),
                    parent: elder,
                    domain: domain,
                    description: `Specializes in ${domain} processing`
                };
                
                simulationState.entities.push(mentor);
                
                // Create Erudites for this Mentor
                const eruditeCount = Math.floor(config.erudites.count / config.mentors.count);
                for (let j = 0; j < eruditeCount; j++) {
                    const eruditeAngle = angle + (j / eruditeCount) * Math.PI * 0.5 - Math.PI * 0.25;
                    const eruditeOrbitRadius = config.erudites.orbitRadiusMin + 
                        (config.erudites.orbitRadiusMax - config.erudites.orbitRadiusMin) * Math.random();
                    
                    const eruditeOrbitCenter = {
                        x: center.x + orbitRadius * Math.cos(angle),
                        y: center.y + orbitRadius * Math.sin(angle)
                    };
                    
                    const erudite = {
                        id: `erudite-${i}-${j}`,
                        type: "erudite",
                        orbitRadius: eruditeOrbitRadius,
                        orbitCenter: eruditeOrbitCenter,
                        radius: config.erudites.radius,
                        color: config.erudites.colors(j / eruditeCount),
                        phase: mentor.phase + j * config.phases.eruditePhaseOffset,
                        phaseVelocity: mentor.phaseVelocity * (0.9 + Math.random() * 0.2),
                        x: eruditeOrbitCenter.x + eruditeOrbitRadius * Math.cos(eruditeAngle),
                        y: eruditeOrbitCenter.y + eruditeOrbitRadius * Math.sin(eruditeAngle),
                        parent: mentor,
                        domain: getEruditeTask(domain, j),
                        description: `Processes specific aspects of ${domain}`
                    };
                    
                    simulationState.entities.push(erudite);
                }
            }
            
            // Render entities
            renderEntities();
        }
        
        function renderEntities() {
            const svg = d3.select("#visualization");
            
            // Remove existing entities
            svg.selectAll(".entity").remove();
            
            // Add entities
            const entityElements = svg.selectAll(".entity")
                .data(simulationState.entities)
                .enter()
                .append("g")
                .attr("class", "entity")
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .on("mouseover", showEntityInfo)
                .on("mouseout", hideEntityInfo);
                
            // Add entity circles
            entityElements.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color)
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.9);
                
            // Add glow effect for Elder
            entityElements.filter(d => d.type === "elder")
                .append("circle")
                .attr("r", d => d.radius * 1.8)
                .attr("fill", "none")
                .attr("stroke", d => d.color)
                .attr("stroke-width", 10)
                .attr("opacity", 0.2)
                .attr("class", "elder-glow");
                
            // Add visual indicator of phase
            entityElements.filter(d => d.type !== "erudite")
                .append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", d => d.radius * Math.cos(d.phase))
                .attr("y2", d => d.radius * Math.sin(d.phase))
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.8);
        }
        
        function updateEntitiesPosition() {
            simulationState.entities.forEach(entity => {
                if (entity.type === "elder") return; // Elder doesn't move
                
                // Update entity's parent position if it's an Erudite
                if (entity.type === "erudite") {
                    const parent = entity.parent;
                    entity.orbitCenter.x = parent.x;
                    entity.orbitCenter.y = parent.y;
                }
                
                // Calculate new position based on phase
                entity.x = entity.orbitCenter.x + entity.orbitRadius * Math.cos(entity.phase);
                entity.y = entity.orbitCenter.y + entity.orbitRadius * Math.sin(entity.phase);
            });
            
            // Update the DOM
            d3.selectAll(".entity")
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
            // Update phase indicators
            d3.selectAll(".entity line")
                .attr("x2", d => d.radius * Math.cos(d.phase))
                .attr("y2", d => d.radius * Math.sin(d.phase));
        }
        
        function updatePhases(deltaTime) {
            // Update Elder phase
            const elder = simulationState.entities[0];
            elder.phase += elder.phaseVelocity * deltaTime * simulationState.speed;
            
            // Normalize to [0, 2π)
            elder.phase = normalizePhase(elder.phase);
            
            // Update display
            document.getElementById("current-phase").textContent = elder.phase.toFixed(2);
            document.getElementById("phase-circle").style.backgroundColor = 
                `hsl(${(elder.phase / (Math.PI * 2)) * 360}, 100%, 50%)`;
                
            // Update Mentor phases with some gravitation toward Elder's phase
            simulationState.entities.filter(e => e.type === "mentor").forEach(mentor => {
                const phaseDiff = calculatePhaseDifference(mentor.phase, elder.phase);
                const attraction = 0.1 * phaseDiff;
                
                mentor.phase += (mentor.phaseVelocity - attraction) * deltaTime * simulationState.speed;
                mentor.phase = normalizePhase(mentor.phase);
            });
            
            // Update Erudite phases with attraction to their Mentor's phase
            simulationState.entities.filter(e => e.type === "erudite").forEach(erudite => {
                const parent = erudite.parent;
                const phaseDiff = calculatePhaseDifference(erudite.phase, parent.phase);
                const attraction = 0.2 * phaseDiff;
                
                erudite.phase += (erudite.phaseVelocity - attraction) * deltaTime * simulationState.speed;
                erudite.phase = normalizePhase(erudite.phase);
            });
            
            // Calculate parameter activation based on Elder phase
            calculateParameterActivation(elder.phase);
        }
        
        function calculateParameterActivation(elderPhase) {
            // Calculate sparsity factor from the system state itself
            const sparsityFactor = calculateSystemDeterminedSparsity();
            
            // Apply syzygy efficiency multiplier if applicable
            const syzygyMultiplier = getSyzygyEfficiencyFactor();
            const effectiveSparsity = sparsityFactor;
            const effectiveParameterCount = config.parameters.totalCount * syzygyMultiplier;
            let activeCount = 0;
            
            // Calculate active parameter count based on determined sparsity
            // Note: With syzygy, we get more "effective parameters" with the same actual parameter count
            // This models how syzygy alignment creates more efficient use of the same parameters
            activeCount = Math.floor(config.parameters.totalCount * effectiveSparsity);
            const effectiveActiveCount = Math.floor(activeCount * syzygyMultiplier);
            
            simulationState.activeParameters = activeCount;
            simulationState.effectiveActiveParameters = effectiveActiveCount;
            
            // Display the effective parameter count with syzygy boost if active
            const displayCount = syzygyMultiplier > 1.0 ? 
                `${activeCount.toLocaleString()} (${effectiveActiveCount.toLocaleString()} effective)` : 
                activeCount.toLocaleString();
                
            document.getElementById("active-count").textContent = displayCount;
            
            // Calculate memory usage (proportional to active parameters)
            const memoryUsage = (activeCount / config.parameters.totalCount) * 
                                config.parameters.peakMemoryMB * 1000;
            document.getElementById("memory-usage").textContent = (memoryUsage / 1000).toFixed(2);
            
            // Update activation history for graph
            simulationState.activationHistory.push(effectiveSparsity);
            simulationState.activationHistory.shift();
            updateActivationGraph();
            
            // Show sparsity factor
            const sparsityDisplay = document.getElementById("sparsity-factor");
            if (sparsityDisplay) {
                sparsityDisplay.textContent = (effectiveSparsity * 100).toFixed(6);
            }
        }
        
        // Syzygy detection and handling functions
        function detectSyzygies() {
            if (!config.parameters.syzygyDetection) return;
            
            const elder = simulationState.entities[0]; // The Elder entity
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            const erudites = simulationState.entities.filter(e => e.type === "erudite");
            
            // Clear previous syzygies
            simulationState.activeSyzygies = [];
            
            // Check for alignments between Elder, Mentors, and Erudites
            mentors.forEach(mentor => {
                const mentorErudites = erudites.filter(e => e.parent === mentor);
                
                mentorErudites.forEach(erudite => {
                    // Calculate vectors for alignment checking
                    const v1 = {
                        x: mentor.x - elder.x,
                        y: mentor.y - elder.y
                    };
                    
                    const v2 = {
                        x: erudite.x - mentor.x,
                        y: erudite.y - mentor.y
                    };
                    
                    // Normalize vectors
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                    
                    if (mag1 === 0 || mag2 === 0) return; // Skip if any magnitude is zero
                    
                    const n1 = { x: v1.x / mag1, y: v1.y / mag1 };
                    const n2 = { x: v2.x / mag2, y: v2.y / mag2 };
                    
                    // Calculate dot product for alignment check
                    const dotProduct = n1.x * n2.x + n1.y * n2.y;
                    
                    // Angle between vectors in radians
                    const angle = Math.acos(Math.min(Math.max(dotProduct, -1), 1));
                    
                    // Check if the angle is close to 0 or π (aligned or anti-aligned)
                    const isAligned = angle < config.parameters.syzygyAngleTolerance || 
                                      Math.abs(angle - Math.PI) < config.parameters.syzygyAngleTolerance;
                    
                    if (isAligned) {
                        const syzygyId = `${mentor.id}-${erudite.id}`;
                        
                        // Add to active syzygies
                        simulationState.activeSyzygies.push({
                            id: syzygyId,
                            elder: elder,
                            mentor: mentor,
                            erudite: erudite,
                            time: Date.now(),
                            isAntiAligned: angle > Math.PI / 2
                        });
                        
                        // Update count for this pair
                        if (!simulationState.syzygyCounts[syzygyId]) {
                            simulationState.syzygyCounts[syzygyId] = 0;
                        }
                        simulationState.syzygyCounts[syzygyId]++;
                        
                        // Record timestamp of most recent syzygy
                        simulationState.lastSyzygyTime = Date.now();
                        
                        // Add to history (limit to 10 most recent)
                        simulationState.syzygyHistory.unshift({
                            id: syzygyId,
                            mentorDomain: mentor.domain,
                            eruditeId: erudite.id,
                            time: Date.now()
                        });
                        
                        if (simulationState.syzygyHistory.length > 10) {
                            simulationState.syzygyHistory.pop();
                        }
                    }
                });
            });
            
            // Update the visualization
            updateSyzygyVisuals();
        }
        
        function updateSyzygyVisuals() {
            const svg = d3.select("#visualization");
            
            // Update syzygy lines
            const syzygyLines = svg.select(".syzygy-lines").selectAll(".syzygy-line")
                .data(simulationState.activeSyzygies, d => d.id);
            
            // Remove old lines
            syzygyLines.exit().remove();
            
            // Add new lines
            syzygyLines.enter()
                .append("path")
                .attr("class", "syzygy-line")
                .merge(syzygyLines)
                .attr("d", d => {
                    // Draw line from Elder through Mentor to Erudite
                    return `M ${d.elder.x} ${d.elder.y} L ${d.mentor.x} ${d.mentor.y} L ${d.erudite.x} ${d.erudite.y}`;
                });
                
            // Update UI elements
            document.getElementById("syzygy-count").textContent = simulationState.activeSyzygies.length;
            
            // Update the latest syzygy info
            if (simulationState.syzygyHistory.length > 0) {
                const latest = simulationState.syzygyHistory[0];
                document.getElementById("syzygy-latest").textContent = `${latest.mentorDomain}`;
            } else {
                document.getElementById("syzygy-latest").textContent = "None";
            }
            
            // Calculate efficiency boost
            const syzygyBoost = getSyzygyEfficiencyFactor();
            document.getElementById("syzygy-efficiency").textContent = syzygyBoost.toFixed(2);
            
            // Update indicator
            const indicator = document.getElementById("syzygy-indicator");
            if (simulationState.activeSyzygies.length > 0) {
                indicator.className = "syzygy-active";
            } else {
                indicator.className = "syzygy-inactive";
            }
        }
        
        function getSyzygyEfficiencyFactor() {
            if (!config.parameters.syzygyDetection || simulationState.activeSyzygies.length === 0) {
                return 1.0;
            }
            
            // Calculate efficiency boost based on number of active syzygies
            // More syzygies = higher efficiency (up to a cap)
            const maxBoost = config.parameters.syzygyBoostFactor;
            const saturationPoint = 10; // Maximum number of syzygies for full boost
            
            return 1.0 + (Math.min(simulationState.activeSyzygies.length, saturationPoint) / saturationPoint) * (maxBoost - 1.0);
        }
        
        function calculateSystemDeterminedSparsity() {
            // This function calculates the sparsity factor from the system's state
            // rather than using a predetermined value
            
            // Get the Elder entity
            const elder = simulationState.entities[0];
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            
            // Base sparsity factor from config
            let baseFactor = config.parameters.sparsityBase;
            
            // Phase concentration factor - measures how concentrated the Mentors
            // are around the Elder in phase space
            let phaseConcentrationSum = 0;
            let phaseConcentrationCount = 0;
            
            mentors.forEach(mentor => {
                // Calculate phase difference between Mentor and Elder
                const phaseDiff = Math.abs(calculatePhaseDifference(mentor.phase, elder.phase));
                
                // Normalize to [0, 1] where 0 means perfect alignment and 1 means maximum difference
                const normalizedDiff = phaseDiff / Math.PI;
                
                // Inverse relationship - closer phases mean higher contribution to sparsity
                const contributionFactor = Math.exp(-5 * normalizedDiff);
                
                phaseConcentrationSum += contributionFactor;
                phaseConcentrationCount++;
            });
            
            // Average phase concentration factor (0 to 1)
            const avgPhaseConcentration = phaseConcentrationCount > 0 ? 
                phaseConcentrationSum / phaseConcentrationCount : 0;
                
            // Orbital harmony factor - measures the regularity of orbital positions
            // Higher harmony means more regular spacing, which reduces sparsity
            let orbitalHarmonyFactor = 0;
            
            // Count Mentors in each phase quadrant
            const quadrants = [0, 0, 0, 0];
            mentors.forEach(mentor => {
                const quadrant = Math.floor((mentor.phase / (Math.PI * 2)) * 4) % 4;
                quadrants[quadrant]++;
            });
            
            // Calculate variance in quadrant distribution
            const avgQuadrantCount = mentors.length / 4;
            let quadrantVariance = 0;
            
            quadrants.forEach(count => {
                quadrantVariance += Math.pow(count - avgQuadrantCount, 2);
            });
            
            quadrantVariance /= 4;
            
            // Normalize to [0, 1] where 0 means perfect distribution (low variance)
            // and 1 means highly imbalanced (high variance)
            const maxPossibleVariance = Math.pow(mentors.length, 2) / 4;
            orbitalHarmonyFactor = 1 - (quadrantVariance / maxPossibleVariance);
            
            // Dynamic phase tolerance - decreases with higher concentration and harmony
            let phaseTolerance = config.parameters.phaseToleranceBase;
            
            if (config.parameters.adaptiveFactors) {
                // Phase tolerance decreases when concentration is high (more selective)
                // but increases when harmony is high (more inclusive of structured patterns)
                phaseTolerance *= (0.5 + 0.5 * (1 - avgPhaseConcentration)) * (0.5 + 0.5 * orbitalHarmonyFactor);
            }
            
            // System state-determined sparsity factor
            // Base factor * adaptive modulation based on concentration and harmony
            let sparsityFactor = baseFactor;
            
            if (config.parameters.adaptiveFactors) {
                // Higher phase concentration leads to lower sparsity (more selective)
                // Higher orbital harmony leads to higher sparsity (more inclusive)
                sparsityFactor *= (0.4 + 0.6 * (1 - avgPhaseConcentration)) * (0.4 + 0.6 * orbitalHarmonyFactor);
                
                // Add some intentional variability based on Elder phase
                // This creates patterns in memory usage over time
                const cyclicalComponent = 0.4 + 0.6 * (0.5 + 0.5 * Math.sin(elder.phase * 3));
                sparsityFactor *= cyclicalComponent;
            }
            
            // Ensure sparsity stays within reasonable bounds
            sparsityFactor = Math.max(baseFactor * 0.1, Math.min(baseFactor * 10, sparsityFactor));
            
            return sparsityFactor;
        }
        
        function createActivationGraph() {
            const graphContainer = document.getElementById("activation-graph");
            const svg = d3.select(graphContainer).append("svg")
                .attr("width", "100%")
                .attr("height", "100%");
                
            // Add a path for the activation curve
            svg.append("path")
                .attr("class", "activation-path")
                .attr("fill", "none")
                .attr("stroke", "#ffcc00")
                .attr("stroke-width", 2);
                
            // Add grid lines
            svg.append("line")
                .attr("x1", 0)
                .attr("x2", "100%")
                .attr("y1", "50%")
                .attr("y2", "50%")
                .attr("stroke", "#334466")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3");
        }
        
        function updateActivationGraph() {
            const svg = d3.select("#activation-graph svg");
            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            const x = d3.scaleLinear()
                .domain([0, simulationState.activationHistory.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, Math.max(0.001, d3.max(simulationState.activationHistory) * 1.2)])
                .range([height, 0]);
                
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d))
                .curve(d3.curveBasis);
                
            svg.select(".activation-path")
                .attr("d", line(simulationState.activationHistory));
        }
        
        let lastTimestamp = 0;
        function animate(timestamp) {
            if (lastTimestamp === 0) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000; // in seconds
            lastTimestamp = timestamp;
            
            if (simulationState.running) {
                updatePhases(deltaTime);
                updateEntitiesPosition();
                updateGlowEffect();
                
                // Detect and update syzygies
                if (config.parameters.syzygyDetection) {
                    detectSyzygies();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function updateGlowEffect() {
            // Pulsating glow effect for Elder
            const elder = simulationState.entities[0];
            const pulseFactor = 1.6 + 0.4 * Math.sin(Date.now() / 1000);
            
            d3.select(".elder-glow")
                .attr("r", elder.radius * pulseFactor)
                .attr("opacity", 0.1 + 0.1 * Math.sin(Date.now() / 500));
        }
        
        function showEntityInfo(event, d) {
            simulationState.selectedEntity = d;
            
            const detailsDiv = document.getElementById("entity-details");
            detailsDiv.innerHTML = `
                <div>
                    <strong>Type:</strong> ${capitalize(d.type)}
                </div>
                <div>
                    <strong>Domain:</strong> ${d.domain}
                </div>
                <div>
                    <strong>Phase:</strong> ${d.phase.toFixed(3)}
                </div>
                <div>
                    <strong>Description:</strong> ${d.description}
                </div>
            `;
            
            // Highlight the entity
            d3.select(this).select("circle")
                .attr("stroke", "#ffcc00")
                .attr("stroke-width", 3);
        }
        
        function hideEntityInfo() {
            simulationState.selectedEntity = null;
            
            // Reset entity highlight
            d3.select(this).select("circle")
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 2);
        }
        
        // Helper functions
        function normalizePhase(phase) {
            while (phase >= Math.PI * 2) phase -= Math.PI * 2;
            while (phase < 0) phase += Math.PI * 2;
            return phase;
        }
        
        function calculatePhaseDifference(phase1, phase2) {
            let diff = phase2 - phase1;
            
            // Normalize to [-π, π]
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            
            return diff;
        }
        
        function getMentorDomain(index) {
            const domains = [
                "Audio Processing", "Visual Analysis", "Semantic Understanding", 
                "Temporal Patterns", "Spatial Relations", "Harmonic Structures",
                "Rhythmic Patterns", "Timbral Analysis", "Melodic Structures",
                "Dynamic Patterns", "Textural Analysis", "Formal Structures",
                "Phonetic Analysis", "Syntactic Structures", "Semantic Networks",
                "Pragmatic Context", "Emotional Content", "Narrative Flow",
                "Visual Textures", "Color Relationships", "Spatial Composition",
                "Temporal Dynamics", "Cross-modal Binding", "Feature Extraction",
                "Statistical Patterns", "Contextual Relations", "Environmental Sounds",
                "Speech Recognition", "Musical Genres", "Cultural Contexts",
                "Acoustic Properties", "Auditory Scene Analysis"
            ];
            
            return domains[index % domains.length];
        }
        
        function getEruditeTask(mentorDomain, index) {
            const audioTasks = [
                "Onset Detection", "Pitch Tracking", "Timbre Classification", 
                "Beat Detection", "Harmonic Analysis", "Envelope Tracking",
                "Transient Detection", "Spectral Analysis", "Dynamic Processing"
            ];
            
            const visualTasks = [
                "Edge Detection", "Object Recognition", "Motion Tracking",
                "Color Analysis", "Texture Classification", "Spatial Composition",
                "Depth Estimation", "Form Recognition", "Illumination Analysis"
            ];
            
            const semanticTasks = [
                "Word Sense", "Entity Recognition", "Relation Extraction",
                "Sentiment Analysis", "Topic Classification", "Contextual Mapping",
                "Metaphor Detection", "Narrative Structure", "Semantic Roles"
            ];
            
            if (mentorDomain.includes("Audio") || mentorDomain.includes("Harmon") || 
                mentorDomain.includes("Rhythm") || mentorDomain.includes("Timb")) {
                return audioTasks[index % audioTasks.length];
            } 
            else if (mentorDomain.includes("Visual") || mentorDomain.includes("Color") || 
                    mentorDomain.includes("Spatial")) {
                return visualTasks[index % visualTasks.length];
            }
            else {
                return semanticTasks[index % semanticTasks.length];
            }
        }
        
        function toggleSimulation() {
            simulationState.running = !simulationState.running;
            document.getElementById("play-pause").textContent = 
                simulationState.running ? "Pause" : "Play";
        }
        
        function resetSimulation() {
            simulationState.elderPhase = config.phases.initElderPhase;
            const center = { 
                x: document.querySelector(".container").clientWidth / 2, 
                y: document.querySelector(".container").clientHeight / 2 
            };
            createEntities(center);
        }
        
        function updateSpeed(event) {
            simulationState.speed = parseFloat(event.target.value);
        }
        
        function capitalize(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
        
        // Initialize the visualization when the page loads
        window.addEventListener("load", init);
        
        // Handle window resize
        window.addEventListener("resize", function() {
            const svg = d3.select("#visualization");
            const container = document.querySelector(".container");
            svg.attr("width", container.clientWidth)
                .attr("height", container.clientHeight);
                
            // Recenter the system
            const center = { x: container.clientWidth / 2, y: container.clientHeight / 2 };
            simulationState.entities[0].x = center.x;
            simulationState.entities[0].y = center.y;
            simulationState.entities[0].orbitCenter = center;
            
            // Update mentor orbit centers
            simulationState.entities.filter(e => e.type === "mentor").forEach(mentor => {
                mentor.orbitCenter = center;
            });
        });
    </script>
</body>
</html>