<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elder Heliosystem Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            color: #eee;
            overflow: hidden;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }
        
        button {
            background-color: #4a5eff;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #6a7eff;
        }
        
        .entity-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        h2 {
            margin-top: 0;
            color: #6a7eff;
        }
        
        .phase-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 10;
        }
        
        .parameter-activation {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            z-index: 100;
        }
        
        .highlight {
            color: #ffcc00;
            font-weight: bold;
        }
        
        .syzygy-monitor {
            position: absolute;
            top: 120px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        .orbital-dynamics {
            position: absolute;
            top: 280px;
            right: 20px;
            background-color: rgba(30, 30, 50, 0.7);
            padding: 15px;
            border-radius: 10px;
            max-width: 300px;
            z-index: 10;
        }
        
        .syzygy-inactive {
            color: #555555;
            font-size: 24px;
            text-align: center;
            margin-top: 5px;
        }
        
        .syzygy-active {
            color: #ff00ff;
            font-size: 24px;
            text-align: center;
            margin-top: 5px;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.3; transform: scale(0.8); }
            50% { opacity: 1.0; transform: scale(1.2); }
            100% { opacity: 0.3; transform: scale(0.8); }
        }
        
        .syzygy-line {
            stroke: rgba(255, 0, 255, 0.6);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            animation: dash 1s linear infinite;
        }
        
        @keyframes dash {
            to { stroke-dashoffset: -10; }
        }
        
        .gravitational-wave {
            fill: none;
            stroke-width: 0.5;
            opacity: 0.3;
            pointer-events: none;
        }
        
        .memory-field {
            fill-opacity: 0.05;
            stroke: none;
            pointer-events: none;
        }
        
        .influence-line {
            pointer-events: none;
        }
        
        .elder-mentor {
            stroke: rgba(255, 215, 0, 0.5);
            stroke-dasharray: 4, 2;
        }
        
        .mentor-erudite {
            stroke: rgba(100, 200, 255, 0.5);
            stroke-dasharray: 3, 2;
        }
        
        .memory-field-elder {
            fill: rgba(255, 85, 0, 0.1);
        }
        
        .memory-field-mentor {
            fill: rgba(100, 150, 255, 0.1);
        }
        
        .wave-pulse {
            animation: wavePulse 3s ease-out infinite;
        }
        
        @keyframes wavePulse {
            0% { opacity: 0; stroke-width: 0.2; }
            50% { opacity: 0.4; stroke-width: 1; }
            100% { opacity: 0; stroke-width: 0.2; }
        }
        
        .entity-controls {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .entity-controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #6a7eff;
        }
        
        .control-group {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        select {
            background-color: #2a2a4a;
            color: white;
            border: none;
            padding: 5px;
            border-radius: 5px;
        }
        
        .entity-fade-in {
            animation: fadeIn 0.8s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h2>Elder Heliosystem</h2>
            <button id="play-pause">Pause</button>
            <button id="reset">Reset</button>
            <div>
                <label for="speed">Simulation Speed:</label>
                <input type="range" id="speed" min="0.1" max="2" step="0.1" value="1">
            </div>
            <div class="entity-controls">
                <h3>Entity Management</h3>
                <div class="control-group">
                    <button id="add-mentor">Add Mentor</button>
                    <select id="mentor-domain">
                        <option value="random">Random Domain</option>
                        <option value="Audio Processing">Audio Processing</option>
                        <option value="Visual Analysis">Visual Analysis</option>
                        <option value="Semantic Understanding">Semantic Understanding</option>
                        <option value="Spatial Relations">Spatial Relations</option>
                        <option value="Multimodal Fusion">Multimodal Fusion</option>
                    </select>
                </div>
                <div class="control-group">
                    <button id="add-erudite">Add Erudite</button>
                    <select id="mentor-select">
                        <option value="random">Random Mentor</option>
                    </select>
                </div>
                <div>
                    <span>Mentors: <span id="mentor-count">0</span></span> | 
                    <span>Erudites: <span id="erudite-count">0</span></span>
                </div>
            </div>
        </div>
        
        <div class="entity-info">
            <h2>Entity Information</h2>
            <p>Hover over an entity to see details</p>
            <div id="entity-details"></div>
        </div>
        
        <div class="phase-indicator">
            <h2>Elder Phase: <span id="current-phase">0.00</span></h2>
            <div id="phase-circle" style="width: 40px; height: 40px; border-radius: 50%; background-color: hsl(210, 100%, 50%); margin: 10px auto;"></div>
        </div>
        
        <div class="parameter-activation">
            <h2>Parameter Activation</h2>
            <div>Active Parameters: <span id="active-count" class="highlight">0</span> / <span id="total-count">1,200,000,000</span></div>
            <div>Memory Usage: <span id="memory-usage" class="highlight">121.34</span> MB</div>
            <div>System-Determined Sparsity: <span id="sparsity-factor" class="highlight">0.0001</span>%</div>
            <div id="activation-graph" style="height: 60px; margin-top: 10px;"></div>
        </div>
        
        <div class="syzygy-monitor">
            <h2>Syzygy Alignment</h2>
            <div>Active Syzygies: <span id="syzygy-count" class="highlight">0</span></div>
            <div>Latest: <span id="syzygy-latest" class="highlight">None</span></div>
            <div>Parameter Efficiency: <span id="syzygy-efficiency" class="highlight">1.0</span>×</div>
            <div id="syzygy-indicator" class="syzygy-inactive">●</div>
        </div>
        
        <div class="orbital-dynamics">
            <h2>Orbital Mechanics</h2>
            <div>Mentor Stability: <span id="mentor-stability" class="highlight">0</span>%</div>
            <div>Erudite Stability: <span id="erudite-stability" class="highlight">0</span>%</div>
            <div>Radial Resonance: <span id="radial-resonance" class="highlight">0</span>%</div>
            <div>Rotation Stability: <span id="rotation-stability" class="highlight">0</span>%</div>
            <div>Stable Revolution: <span id="revolution-stability" class="status-pending">Forming</span></div>
            <div>System Convergence: <span id="system-convergence" class="highlight">Forming</span></div>
        </div>
        
        <style>
            .status-pending {
                color: #ffcc00;
                font-weight: bold;
            }
            .status-good {
                color: #88ff88;
                font-weight: bold;
            }
        </style>
        
        <svg id="visualization"></svg>
        
        <div class="tooltip" style="display: none;"></div>
    </div>

    <script>
        // Configuration
        const config = {
            elder: {
                count: 1,
                radius: 30,
                color: "#ff5500",
                orbitRadius: 0
            },
            mentors: {
                count: 32,
                radius: 12,
                colors: d3.scaleSequential(d3.interpolateRainbow),
                orbitRadius: 200
            },
            erudites: {
                count: 128, // Showing a subset for visualization performance
                radius: 4,
                colors: d3.scaleSequential(d3.interpolateCool),
                orbitRadiusMin: 40,
                orbitRadiusMax: 80
            },
            phases: {
                initElderPhase: 0,
                elderPhaseVelocity: 0.005,
                mentorPhaseOffset: Math.PI / 16,
                eruditePhaseOffset: Math.PI / 32,
                // Orbital stability parameters for stable revolution
                mentorBaseVelocity: 0.015,  // Base velocity for mentors
                eruditeBaseVelocity: 0.025, // Base velocity for erudites
                elderInfluence: 0.08,       // How strongly Elder influences Mentor orbits (0-1)
                mentorInfluence: 0.15,      // How strongly Mentors influence Erudite orbits (0-1)
                stabilityThreshold: 0.85,   // Threshold for considering orbits stable (0-1)
                resonanceRatios: [1, 2, 3, 5, 8] // Fibonacci-like sequence for orbital resonance
            },
            parameters: {
                totalCount: 1200000000,
                peakMemoryMB: 121.34,
                // Sparsity calculation parameters
                sparsityBase: 0.0001, // Base sparsity factor
                phaseToleranceBase: 0.025, // Base phase tolerance
                adaptiveFactors: true, // Whether sparsity adapts to system state
                // Syzygy configuration
                syzygyDetection: true, // Whether to detect syzygy alignments
                syzygyAngleTolerance: 0.05, // Angular tolerance in radians for syzygy detection
                syzygyBoostFactor: 5.0, // How much to boost parameter efficiency during syzygy
                
                // Memory fields configuration
                memoryFields: {
                    enabled: true,
                    elderRadius: 350,
                    mentorRadius: 100,
                    opacity: 0.1,
                    pulseFrequency: 0.2  // How often to pulse (0-1)
                },
                
                // Gravitational waves configuration
                gravitationalWaves: {
                    enabled: true,
                    maxWaves: 8,  // Maximum number of waves displayed at once
                    waveInterval: 2000,  // Milliseconds between wave emissions
                    waveSpeed: 0.5,  // Wave propagation speed
                    waveColors: {
                        elder: "rgba(255, 85, 0, 0.3)",
                        mentor: "rgba(100, 150, 255, 0.3)",
                        erudite: "rgba(0, 255, 150, 0.2)"
                    }
                }
            }
        };
        
        // Simulation state
        let simulationState = {
            running: true,
            speed: 1,
            elderPhase: config.phases.initElderPhase,
            entities: [],
            activeParameters: 0,
            activationHistory: Array(100).fill(0),
            selectedEntity: null,
            // Syzygy tracking
            activeSyzygies: [], // Array of current syzygy triplets (Elder-Mentor-Erudite)
            syzygyCounts: {}, // Counts of syzygies by Mentor-Erudite pair
            syzygyHistory: [], // Array of recent syzygy events
            lastSyzygyTime: 0, // Time of last syzygy event
            
            // Memory and gravitational wave tracking
            memoryFields: [], // Memory fields data
            gravitationalWaves: [], // Active gravitational waves data
            lastWaveTime: 0, // Time of last wave emission
            waveId: 0, // Counter for unique wave IDs
            
            // Orbital mechanics tracking
            orbitalStability: {
                mentors: 0,  // 0-100% stability measure for mentors
                erudites: 0  // 0-100% stability measure for erudites
            },
            radialResonance: 0, // System-wide resonance measure (0-100%)
            rotationStability: 0, // Stability of rotation vs. orbit periods (0-100%)
            stableRevolution: false, // Whether system has achieved stable revolution
            influenceLines: [], // Visual indicators of Elder→Mentor and Mentor→Erudite influence
            lastInfluenceUpdate: 0, // Time of last influence lines update
            startTime: performance.now() // Reference time for time-based stability improvements
        };
        
        // Initialize the visualization
        function init() {
            const svg = d3.select("#visualization");
            const container = document.querySelector(".container");
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Update parameter display
            document.getElementById("total-count").textContent = config.parameters.totalCount.toLocaleString();
            document.getElementById("sparsity-factor").textContent = (config.parameters.sparsityBase * 100).toFixed(6);
            
            // Create groups for various visualization elements
            svg.append("g").attr("class", "memory-fields");
            svg.append("g").attr("class", "gravitational-waves");
            svg.append("g").attr("class", "syzygy-lines");
            svg.append("g").attr("class", "influence-lines");
            
            svg.attr("width", width)
                .attr("height", height);
            
            // Create starfield background
            const starCount = 500;
            const stars = [];
            
            for (let i = 0; i < starCount; i++) {
                stars.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: Math.random() * 1.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
            
            svg.selectAll(".star")
                .data(stars)
                .enter()
                .append("circle")
                .attr("class", "star")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => d.radius)
                .attr("fill", "#ffffff")
                .attr("opacity", d => d.opacity);
                
            // Create orbit paths
            const center = { x: width / 2, y: height / 2 };
            
            // Mentor orbit
            svg.append("circle")
                .attr("cx", center.x)
                .attr("cy", center.y)
                .attr("r", config.mentors.orbitRadius)
                .attr("fill", "none")
                .attr("stroke", "#334466")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3");
                
            // Create entities
            createEntities(center);
            
            // Update the mentor select dropdown
            updateMentorSelectDropdown();
            
            // Create parameters activation visualization
            createActivationGraph();
            
            // Set up event listeners
            document.getElementById("play-pause").addEventListener("click", toggleSimulation);
            document.getElementById("reset").addEventListener("click", resetSimulation);
            document.getElementById("speed").addEventListener("input", updateSpeed);
            document.getElementById("add-mentor").addEventListener("click", addNewMentor);
            document.getElementById("add-erudite").addEventListener("click", addNewErudite);
            
            // Update entity counts
            updateEntityCountsDisplay();
            
            // Create memory fields
            createMemoryFields();
            
            // Start animation loop
            requestAnimationFrame(animate);
        }
        
        // Function to add a new Mentor to the system
        function addNewMentor() {
            const svg = d3.select("#visualization");
            const container = document.querySelector(".container");
            const width = container.clientWidth;
            const height = container.clientHeight;
            const center = { x: width / 2, y: height / 2 };
            
            // Get the Elder entity (always the first one)
            const elder = simulationState.entities.find(e => e.type === "elder");
            
            // Get the domain selection
            const domainSelect = document.getElementById("mentor-domain");
            let domain = domainSelect.value;
            
            // If random is selected, get a random domain
            if (domain === "random") {
                const randomIndex = Math.floor(Math.random() * 32);
                domain = getMentorDomain(randomIndex);
            }
            
            // Count existing mentors to determine the index
            const mentorCount = simulationState.entities.filter(e => e.type === "mentor").length;
            const mentorIndex = mentorCount;
            
            // Calculate position angle - distribute new mentors evenly around Elder
            const angle = (mentorIndex / (mentorCount + 1)) * Math.PI * 2;
            const orbitRadius = config.mentors.orbitRadius;
            
            // Create new Mentor entity
            const mentor = {
                id: `mentor-${mentorIndex}`,
                type: "mentor",
                orbitRadius: orbitRadius,
                orbitCenter: { x: center.x, y: center.y },
                radius: config.mentors.radius,
                color: config.mentors.colors(mentorIndex / (mentorCount + 1)),
                phase: simulationState.elderPhase + mentorIndex * config.phases.mentorPhaseOffset,
                phaseVelocity: config.phases.elderPhaseVelocity * (0.8 + Math.random() * 0.4),
                x: center.x + orbitRadius * Math.cos(angle),
                y: center.y + orbitRadius * Math.sin(angle),
                parent: elder,
                domain: domain,
                description: `Specializes in ${domain} processing`,
                isNew: true
            };
            
            // Add the new mentor to the simulation
            simulationState.entities.push(mentor);
            
            // Update the mentor select dropdown
            updateMentorSelectDropdown();
            
            // Render the new entity
            renderEntities();
            
            // Update entity count display
            updateEntityCountsDisplay();
            
            // Update memory fields for new mentor
            createMemoryFields();
            
            // Emit a celebratory gravitational wave
            const timestamp = performance.now();
            simulationState.lastWaveTime = timestamp - config.parameters.gravitationalWaves.waveInterval;
            emitGravitationalWave(timestamp);
        }
        
        // Function to add a new Erudite to the system
        function addNewErudite() {
            const container = document.querySelector(".container");
            const width = container.clientWidth;
            const height = container.clientHeight;
            const center = { x: width / 2, y: height / 2 };
            
            // Get mentor selection
            const mentorSelect = document.getElementById("mentor-select");
            let selectedMentorId = mentorSelect.value;
            
            // Get all mentors
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            if (mentors.length === 0) {
                // Can't add an erudite without a mentor
                alert("Please add at least one Mentor first.");
                return;
            }
            
            // If random is selected, choose a random mentor
            let selectedMentor;
            if (selectedMentorId === "random") {
                const randomIndex = Math.floor(Math.random() * mentors.length);
                selectedMentor = mentors[randomIndex];
            } else {
                selectedMentor = mentors.find(m => m.id === selectedMentorId);
            }
            
            if (!selectedMentor) {
                selectedMentor = mentors[0]; // Fallback to first mentor
            }
            
            // Count existing erudites for this mentor
            const eruditeCount = simulationState.entities.filter(
                e => e.type === "erudite" && e.parent.id === selectedMentor.id
            ).length;
            
            // Calculate position
            const mentorAngle = Math.atan2(
                selectedMentor.y - center.y,
                selectedMentor.x - center.x
            );
            
            const eruditeAngle = mentorAngle + (eruditeCount / 8) * Math.PI * 0.5 - Math.PI * 0.25;
            const eruditeOrbitRadius = config.erudites.orbitRadiusMin + 
                (config.erudites.orbitRadiusMax - config.erudites.orbitRadiusMin) * Math.random();
            
            const eruditeOrbitCenter = {
                x: selectedMentor.x,
                y: selectedMentor.y
            };
            
            // Create the new Erudite
            const erudite = {
                id: `erudite-${selectedMentor.id.split('-')[1]}-${eruditeCount}`,
                type: "erudite",
                orbitRadius: eruditeOrbitRadius,
                orbitCenter: eruditeOrbitCenter,
                radius: config.erudites.radius,
                color: config.erudites.colors(eruditeCount / 8),
                phase: selectedMentor.phase + eruditeCount * config.phases.eruditePhaseOffset,
                phaseVelocity: selectedMentor.phaseVelocity * (0.9 + Math.random() * 0.2),
                x: eruditeOrbitCenter.x + eruditeOrbitRadius * Math.cos(eruditeAngle),
                y: eruditeOrbitCenter.y + eruditeOrbitRadius * Math.sin(eruditeAngle),
                parent: selectedMentor,
                domain: getEruditeTask(selectedMentor.domain, eruditeCount),
                description: `Processes specific aspects of ${selectedMentor.domain}`,
                isNew: true
            };
            
            // Add the new erudite to the simulation
            simulationState.entities.push(erudite);
            
            // Render the new entity
            renderEntities();
            
            // Update entity count display
            updateEntityCountsDisplay();
            
            // Update memory fields for new erudite
            createMemoryFields();
            
            // Emit a celebratory gravitational wave
            const timestamp = performance.now();
            simulationState.lastWaveTime = timestamp - config.parameters.gravitationalWaves.waveInterval;
            emitGravitationalWave(timestamp);
        }
        
        // Function to update the mentor select dropdown
        function updateMentorSelectDropdown() {
            const mentorSelect = document.getElementById("mentor-select");
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            
            // Clear existing options except the first one (Random)
            while (mentorSelect.options.length > 1) {
                mentorSelect.remove(1);
            }
            
            // Add options for each mentor
            mentors.forEach(mentor => {
                const option = document.createElement("option");
                option.value = mentor.id;
                option.text = `${mentor.domain} (${mentor.id})`;
                mentorSelect.add(option);
            });
        }
        
        // Function to update entity counts display
        function updateEntityCountsDisplay() {
            const mentorCount = simulationState.entities.filter(e => e.type === "mentor").length;
            const eruditeCount = simulationState.entities.filter(e => e.type === "erudite").length;
            
            document.getElementById("mentor-count").textContent = mentorCount;
            document.getElementById("erudite-count").textContent = eruditeCount;
        }
        
        // Update Erudite orbit centers when Mentors move
        function updateEruditeOrbitCenters() {
            simulationState.entities.forEach(entity => {
                if (entity.type === "erudite" && entity.parent) {
                    entity.orbitCenter.x = entity.parent.x;
                    entity.orbitCenter.y = entity.parent.y;
                }
            });
        }
        
        // Create and update memory fields
        function createMemoryFields() {
            if (!config.parameters.memoryFields.enabled) return;
            
            const elderEntity = simulationState.entities.find(e => e.type === "elder");
            const mentorEntities = simulationState.entities.filter(e => e.type === "mentor");
            
            // Clear existing memory fields
            simulationState.memoryFields = [];
            
            // Create Elder memory field
            simulationState.memoryFields.push({
                type: "elder",
                entity: elderEntity,
                radius: config.parameters.memoryFields.elderRadius,
                x: elderEntity.x,
                y: elderEntity.y,
                opacity: config.parameters.memoryFields.opacity
            });
            
            // Create Mentor memory fields
            mentorEntities.forEach(mentor => {
                simulationState.memoryFields.push({
                    type: "mentor",
                    entity: mentor,
                    radius: config.parameters.memoryFields.mentorRadius,
                    x: mentor.x,
                    y: mentor.y,
                    opacity: config.parameters.memoryFields.opacity * 0.8
                });
            });
            
            renderMemoryFields();
        }
        
        // Render memory fields
        function renderMemoryFields() {
            const svg = d3.select("#visualization");
            const memoryFieldsGroup = svg.select(".memory-fields");
            
            // Remove existing memory fields
            memoryFieldsGroup.selectAll("*").remove();
            
            // Add memory fields
            memoryFieldsGroup.selectAll(".memory-field")
                .data(simulationState.memoryFields)
                .enter()
                .append("circle")
                .attr("class", d => `memory-field memory-field-${d.type}`)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .attr("r", d => d.radius)
                .attr("fill-opacity", d => d.opacity)
                .attr("fill", d => {
                    if (d.type === "elder") return "url(#elderGradient)";
                    return "url(#mentorGradient)";
                });
            
            // Add gradients if they don't exist yet
            const defs = svg.select("defs");
            if (defs.empty()) {
                svg.append("defs")
                    .html(`
                        <radialGradient id="elderGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                            <stop offset="0%" style="stop-color:rgb(255,100,50);stop-opacity:0.2" />
                            <stop offset="100%" style="stop-color:rgb(255,80,0);stop-opacity:0" />
                        </radialGradient>
                        <radialGradient id="mentorGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
                            <stop offset="0%" style="stop-color:rgb(100,150,255);stop-opacity:0.15" />
                            <stop offset="100%" style="stop-color:rgb(70,120,255);stop-opacity:0" />
                        </radialGradient>
                    `);
            }
        }
        
        // Update memory fields positions
        function updateMemoryFields() {
            if (!config.parameters.memoryFields.enabled) return;
            
            simulationState.memoryFields.forEach(field => {
                field.x = field.entity.x;
                field.y = field.entity.y;
            });
            
            // Update positions in visualization
            const memoryFieldsGroup = d3.select(".memory-fields");
            memoryFieldsGroup.selectAll(".memory-field")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);
                
            // Occasionally pulse the fields for visual effect
            if (Math.random() < config.parameters.memoryFields.pulseFrequency) {
                const randomField = memoryFieldsGroup.selectAll(".memory-field")
                    .filter((d, i) => i === Math.floor(Math.random() * simulationState.memoryFields.length));
                    
                randomField
                    .transition()
                    .duration(1000)
                    .attr("fill-opacity", d => d.opacity * 2)
                    .transition()
                    .duration(1000)
                    .attr("fill-opacity", d => d.opacity);
            }
        }
        
        // Create gravitational waves
        function emitGravitationalWave(timestamp) {
            if (!config.parameters.gravitationalWaves.enabled) return;
            
            // Check if it's time to emit a new wave
            if (timestamp - simulationState.lastWaveTime < config.parameters.gravitationalWaves.waveInterval) {
                return;
            }
            
            // Update last wave time
            simulationState.lastWaveTime = timestamp;
            
            // Choose random entity to emit wave
            const entitiesWeighted = [
                ...simulationState.entities.filter(e => e.type === "elder"),
                ...simulationState.entities.filter(e => e.type === "elder"), // Add elder twice to increase probability
                ...simulationState.entities.filter(e => e.type === "mentor").slice(0, 3) // Limit to 3 random mentors
            ];
            
            if (entitiesWeighted.length === 0) return;
            
            const sourceEntity = entitiesWeighted[Math.floor(Math.random() * entitiesWeighted.length)];
            
            // Create wave
            const newWave = {
                id: `wave-${simulationState.waveId++}`,
                sourceType: sourceEntity.type,
                sourceX: sourceEntity.x,
                sourceY: sourceEntity.y,
                currentRadius: 10, // Start with small radius
                color: config.parameters.gravitationalWaves.waveColors[sourceEntity.type],
                createdAt: timestamp,
                speed: config.parameters.gravitationalWaves.waveSpeed *
                       (sourceEntity.type === "elder" ? 1.2 : 0.8) // Elder waves move faster
            };
            
            // Add to waves array
            simulationState.gravitationalWaves.push(newWave);
            
            // Limit number of waves
            if (simulationState.gravitationalWaves.length > config.parameters.gravitationalWaves.maxWaves) {
                simulationState.gravitationalWaves.shift(); // Remove oldest wave
            }
            
            // Render waves
            renderGravitationalWaves();
        }
        
        // Update gravitational waves
        function updateGravitationalWaves(deltaTime) {
            if (!config.parameters.gravitationalWaves.enabled) return;
            
            // Update wave radii
            let hasUpdates = false;
            simulationState.gravitationalWaves = simulationState.gravitationalWaves.filter(wave => {
                // Expand the wave
                wave.currentRadius += wave.speed * 100 * deltaTime;
                
                // Remove waves that have grown too large
                const maxRadius = 800; // Maximum wave radius before it fades out
                if (wave.currentRadius > maxRadius) {
                    return false;
                }
                
                hasUpdates = true;
                return true;
            });
            
            // Update visualization if needed
            if (hasUpdates) {
                const wavesGroup = d3.select(".gravitational-waves");
                
                // Update each wave
                wavesGroup.selectAll(".gravitational-wave")
                    .data(simulationState.gravitationalWaves, d => d.id)
                    .attr("r", d => d.currentRadius)
                    .attr("opacity", d => Math.max(0, 0.4 - d.currentRadius / 800)); // Fade out as it expands
            }
        }
        
        // Render gravitational waves
        function renderGravitationalWaves() {
            const svg = d3.select("#visualization");
            const wavesGroup = svg.select(".gravitational-waves");
            
            // Add new waves
            const waves = wavesGroup.selectAll(".gravitational-wave")
                .data(simulationState.gravitationalWaves, d => d.id);
                
            // Enter new waves
            waves.enter()
                .append("circle")
                .attr("class", "gravitational-wave wave-pulse")
                .attr("cx", d => d.sourceX)
                .attr("cy", d => d.sourceY)
                .attr("r", d => d.currentRadius)
                .attr("stroke", d => d.color)
                .attr("opacity", 0.4);
                
            // Exit old waves
            waves.exit().remove();
        }
        
        function createEntities(center) {
            const svg = d3.select("#visualization");
            simulationState.entities = [];
            
            // Create Elder
            const elder = {
                id: "elder-0",
                type: "elder",
                x: center.x,
                y: center.y,
                radius: config.elder.radius,
                color: config.elder.color,
                phase: config.phases.initElderPhase,
                phaseVelocity: config.phases.elderPhaseVelocity,
                orbitRadius: 0,
                orbitCenter: { x: center.x, y: center.y },
                parent: null,
                domain: "Global",
                description: "Central entity governing the entire system through phase coordination"
            };
            
            simulationState.entities.push(elder);
            
            // Create Mentors
            for (let i = 0; i < config.mentors.count; i++) {
                const angle = (i / config.mentors.count) * Math.PI * 2;
                
                // Calculate orbit radius using resonance ratios for more stable orbits
                // Use Fibonacci-like resonance ratios to distribute mentors at harmonically stable distances
                const resonanceRatios = [1, 2, 3, 5, 8, 13];
                const ratioIndex = i % resonanceRatios.length;
                const resonanceFactor = resonanceRatios[ratioIndex] / resonanceRatios[0];
                
                // Apply a slight jitter to prevent exact overlaps while maintaining resonance
                const jitter = 0.95 + (Math.random() * 0.1);
                const orbitRadius = config.mentors.orbitRadius * Math.sqrt(resonanceFactor) * jitter;
                
                const domain = getMentorDomain(i);
                
                // Calculate phase velocity based on Kepler's Third Law: P² ∝ a³
                // Adjusting for resonance in the Elder Heliosystem
                const orbitalPeriodFactor = Math.pow(resonanceFactor, 1.5); // T² ∝ r³
                const baseVelocity = config.phases.elderPhaseVelocity * 3 / orbitalPeriodFactor;
                
                const mentor = {
                    id: `mentor-${i}`,
                    type: "mentor",
                    orbitRadius: orbitRadius,
                    orbitCenter: { x: center.x, y: center.y },
                    radius: config.mentors.radius,
                    color: config.mentors.colors(i / config.mentors.count),
                    phase: config.phases.initElderPhase + i * config.phases.mentorPhaseOffset,
                    phaseVelocity: baseVelocity,
                    resonanceFactor: resonanceFactor,
                    stabilityFactor: 0,  // Will be updated during simulation
                    orbitalPeriod: Math.round(2 * Math.PI / baseVelocity),
                    x: center.x + orbitRadius * Math.cos(angle),
                    y: center.y + orbitRadius * Math.sin(angle),
                    parent: elder,
                    domain: domain,
                    description: `Specializes in ${domain} processing`,
                    rotationAngle: 0 // Starting rotation angle
                };
                
                simulationState.entities.push(mentor);
                
                // Create Erudites for this Mentor
                const eruditeCount = Math.floor(config.erudites.count / config.mentors.count);
                for (let j = 0; j < eruditeCount; j++) {
                    // Use golden ratio for angular distribution to avoid clustering
                    const goldenRatio = 1.618033988749895;
                    const eruditeAngle = angle + j * goldenRatio * Math.PI;
                    
                    // Use resonance ratios for orbital radii
                    const resonanceRatios = [1, 1.618, 2.618, 4.236]; // Fibonacci ratio based
                    const ratioIndex = j % resonanceRatios.length;
                    const eruditeResonanceFactor = resonanceRatios[ratioIndex];
                    
                    // Calculate radius with resonance factor and small jitter for natural appearance
                    const baseRadius = config.erudites.orbitRadiusMin;
                    const jitter = 0.95 + (Math.random() * 0.1);
                    const eruditeOrbitRadius = baseRadius * Math.sqrt(eruditeResonanceFactor) * jitter;
                    
                    const eruditeOrbitCenter = {
                        x: center.x + orbitRadius * Math.cos(angle),
                        y: center.y + orbitRadius * Math.sin(angle)
                    };
                    
                    // Calculate phase velocity based on orbital mechanics principles
                    // Erudites further from their Mentor move slower
                    const orbitalPeriodFactor = Math.pow(eruditeResonanceFactor, 1.5);
                    const baseEruditeVelocity = mentor.phaseVelocity * 2.5 / orbitalPeriodFactor;
                    
                    const erudite = {
                        id: `erudite-${i}-${j}`,
                        type: "erudite",
                        orbitRadius: eruditeOrbitRadius,
                        orbitCenter: eruditeOrbitCenter,
                        radius: config.erudites.radius,
                        color: config.erudites.colors(j / eruditeCount),
                        phase: mentor.phase + j * config.phases.eruditePhaseOffset,
                        phaseVelocity: baseEruditeVelocity,
                        resonanceFactor: eruditeResonanceFactor,
                        stabilityFactor: 0, // Will be updated during simulation
                        orbitalPeriod: Math.round(2 * Math.PI / baseEruditeVelocity),
                        x: eruditeOrbitCenter.x + eruditeOrbitRadius * Math.cos(eruditeAngle),
                        y: eruditeOrbitCenter.y + eruditeOrbitRadius * Math.sin(eruditeAngle),
                        parent: mentor,
                        domain: getEruditeTask(domain, j),
                        description: `Processes specific aspects of ${domain}`,
                        rotationAngle: 0 // Starting rotation angle
                    };
                    
                    simulationState.entities.push(erudite);
                }
            }
            
            // Render entities
            renderEntities();
        }
        
        function renderEntities() {
            const svg = d3.select("#visualization");
            
            // Remove existing entities
            svg.selectAll(".entity").remove();
            
            // Add entities
            const entityElements = svg.selectAll(".entity")
                .data(simulationState.entities)
                .enter()
                .append("g")
                .attr("class", d => {
                    // Add fade-in animation class for new entities
                    return d.isNew ? "entity entity-fade-in" : "entity";
                })
                .attr("transform", d => `translate(${d.x}, ${d.y})`)
                .on("mouseover", showEntityInfo)
                .on("mouseout", hideEntityInfo);
                
            // Add entity circles with rotation patterns
            entityElements.append("circle")
                .attr("r", d => d.radius)
                .attr("fill", d => d.color)
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.9);
            
            // Add rotation indicators - different for each entity type
            entityElements.each(function(d) {
                const entityGroup = d3.select(this);
                const rotationAngle = d.rotationAngle || 0;
                
                if (d.type === "elder") {
                    // Elder has solar flare-like patterns
                    const flareCount = 8;
                    for (let i = 0; i < flareCount; i++) {
                        const angle = (i / flareCount) * Math.PI * 2 + rotationAngle;
                        const x = Math.cos(angle) * d.radius;
                        const y = Math.sin(angle) * d.radius;
                        
                        entityGroup.append("path")
                            .attr("d", `M 0,0 L ${x * 0.7},${y * 0.7}`)
                            .attr("stroke", "#ffdd00")
                            .attr("stroke-width", d.radius * 0.2)
                            .attr("opacity", 0.5);
                    }
                } else if (d.type === "mentor") {
                    // Mentors have equatorial bands
                    entityGroup.append("ellipse")
                        .attr("rx", d.radius * 0.8)
                        .attr("ry", d.radius * 0.3)
                        .attr("transform", `rotate(${rotationAngle * (180/Math.PI)})`)
                        .attr("fill", d3.rgb(d.color).brighter(0.5).toString())
                        .attr("opacity", 0.6);
                } else if (d.type === "erudite") {
                    // Erudites have meridional markers
                    entityGroup.append("line")
                        .attr("x1", -d.radius * 0.7)
                        .attr("y1", 0)
                        .attr("x2", d.radius * 0.7)
                        .attr("y2", 0)
                        .attr("transform", `rotate(${rotationAngle * (180/Math.PI)})`)
                        .attr("stroke", "#ffffff")
                        .attr("stroke-width", 1.5)
                        .attr("opacity", 0.8);
                }
                
                // Add stability indicators for entities that have been through stability calculation
                if (d.stabilityFactor !== undefined) {
                    // Color indicates stability level
                    const stabilityColor = d.stabilityFactor > 0.85 ? "#88ff88" : 
                                          d.stabilityFactor > 0.5 ? "#ffff88" : "#ff8888";
                    
                    entityGroup.append("circle")
                        .attr("r", d.radius * 1.2)
                        .attr("fill", "none")
                        .attr("stroke", stabilityColor)
                        .attr("stroke-width", 1.5)
                        .attr("opacity", 0.3 + 0.5 * d.stabilityFactor)
                        .attr("stroke-dasharray", d.stabilityFactor > 0.85 ? "none" : "2,2");
                }
            });
            
            // Add glow effect for Elder
            entityElements.filter(d => d.type === "elder")
                .append("circle")
                .attr("r", d => d.radius * 1.8)
                .attr("fill", "none")
                .attr("stroke", d => d.color)
                .attr("stroke-width", 10)
                .attr("opacity", 0.2)
                .attr("class", "elder-glow");
                
            // Add special effect for new Mentors
            entityElements.filter(d => d.type === "mentor" && d.isNew)
                .append("circle")
                .attr("r", d => d.radius * 2.0)
                .attr("fill", "none")
                .attr("stroke", d => d.color)
                .attr("stroke-width", 3)
                .attr("opacity", 0.5)
                .attr("class", "mentor-glow")
                .style("animation", "pulse 2s ease-out")
                .style("animation-iteration-count", "2");
                
            // Remove the isNew flag after rendering
            simulationState.entities.forEach(entity => {
                if (entity.isNew) entity.isNew = false;
            });
                
            // Add visual indicator of phase
            entityElements.filter(d => d.type !== "erudite")
                .append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", d => d.radius * Math.cos(d.phase))
                .attr("y2", d => d.radius * Math.sin(d.phase))
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 2)
                .attr("opacity", 0.8);
        }
        
        function updateEntitiesPosition() {
            simulationState.entities.forEach(entity => {
                if (entity.type === "elder") return; // Elder doesn't move
                
                // Update entity's parent position if it's an Erudite
                if (entity.type === "erudite") {
                    const parent = entity.parent;
                    entity.orbitCenter.x = parent.x;
                    entity.orbitCenter.y = parent.y;
                }
                
                // Calculate new position based on phase
                entity.x = entity.orbitCenter.x + entity.orbitRadius * Math.cos(entity.phase);
                entity.y = entity.orbitCenter.y + entity.orbitRadius * Math.sin(entity.phase);
            });
            
            // Update the DOM
            d3.selectAll(".entity")
                .attr("transform", d => `translate(${d.x}, ${d.y})`);
                
            // Update phase indicators
            d3.selectAll(".entity line")
                .attr("x2", d => d.radius * Math.cos(d.phase))
                .attr("y2", d => d.radius * Math.sin(d.phase));
        }
        
        function updatePhases(deltaTime) {
            // Update Elder phase
            const elder = simulationState.entities[0];
            elder.phase += elder.phaseVelocity * deltaTime * simulationState.speed;
            
            // Normalize to [0, 2π)
            elder.phase = normalizePhase(elder.phase);
            
            // Update Elder rotation - the central entity also rotates on its axis
            elder.rotationAngle = (elder.rotationAngle || 0) + (elder.phaseVelocity * 0.2 * deltaTime * simulationState.speed);
            
            // Update display
            document.getElementById("current-phase").textContent = elder.phase.toFixed(2);
            document.getElementById("phase-circle").style.backgroundColor = 
                `hsl(${(elder.phase / (Math.PI * 2)) * 360}, 100%, 50%)`;
            
            // Track orbital stability metrics for Mentors and Erudites
            let mentorStabilitySum = 0;
            let eruditeStabilitySum = 0;
            let mentorCount = 0;
            let eruditeCount = 0;
            
            // Constants for stable revolution
            const ELDER_INFLUENCE = 0.05; // How strongly Elder asserts revolution of Mentors
            const MENTOR_INFLUENCE = 0.08; // How strongly Mentors assert revolution of Erudites
            const STABILITY_THRESHOLD = 0.85; // Threshold for considering orbits stable
            const STABILITY_EMPHASIS = 0.8; // How much to emphasize stability vs natural orbital velocity
            
            // Time-based stability increase - system stabilizes over time
            const runTime = (performance.now() - simulationState.startTime) / 1000;
            const timeStabilityBoost = Math.min(0.5, runTime / 60); // Max boost of 0.5 after 1 minute
                
            // Update Mentor phases with Elder influence ensuring continuous revolutions
            simulationState.entities.filter(e => e.type === "mentor").forEach(mentor => {
                // Elder influence asserts continuous revolution of Mentors
                // Phase difference between Elder and Mentor
                const phaseDiff = calculatePhaseDifference(mentor.phase, elder.phase);
                
                // Calculate how strongly the Elder's phase should influence the Mentor
                // The influence is stronger when the Mentor is further from the ideal phase relationship
                const baseAttraction = ELDER_INFLUENCE * phaseDiff;
                
                // Stabilization effect increases over time
                const timeBoost = timeStabilityBoost * Math.sign(phaseDiff) * Math.abs(phaseDiff);
                const attraction = baseAttraction + timeBoost;
                
                // Calculate mentor orbital stability (inverse of phase difference)
                // Perfect stability (1.0) when phase difference is 0
                // Minimum stability (0.0) when phase difference is π (completely opposite)
                const stabilityFactor = Math.max(0, 1 - Math.abs(phaseDiff) / Math.PI);
                mentorStabilitySum += stabilityFactor;
                mentorCount++;
                
                // Store stability factor in the entity for visualization purposes
                mentor.stabilityFactor = stabilityFactor;
                
                // Update mentor phase with Elder influence
                // The greater the phase difference, the stronger the Elder's influence
                // When stability is high, natural orbital velocity dominates
                // When stability is low, Elder's influence is stronger
                const velocityComponent = mentor.phaseVelocity * (STABILITY_EMPHASIS + (1 - STABILITY_EMPHASIS) * stabilityFactor);
                const influenceComponent = -attraction * (1 - stabilityFactor * STABILITY_EMPHASIS);
                
                mentor.phase += (velocityComponent + influenceComponent) * deltaTime * simulationState.speed;
                mentor.phase = normalizePhase(mentor.phase);
                
                // Update rotation - Mentors also rotate on their axes
                // Rotation speed is related to orbital period for visual interest
                mentor.rotationAngle = (mentor.rotationAngle || 0) + (mentor.phaseVelocity * 0.5 * deltaTime * simulationState.speed);
            });
            
            // Update Erudite phases with Mentor influence ensuring continuous revolutions
            simulationState.entities.filter(e => e.type === "erudite").forEach(erudite => {
                const parent = erudite.parent;
                
                // Mentor influence asserts continuous revolution of Erudites
                // Phase difference between Mentor and Erudite
                const phaseDiff = calculatePhaseDifference(erudite.phase, parent.phase);
                
                // Calculate how strongly the Mentor's phase should influence the Erudite
                // The influence is stronger when the Erudite is further from the ideal phase relationship
                const baseAttraction = MENTOR_INFLUENCE * phaseDiff;
                
                // Stabilization effect increases over time
                const timeBoost = timeStabilityBoost * Math.sign(phaseDiff) * Math.abs(phaseDiff);
                const attraction = baseAttraction + timeBoost;
                
                // Calculate erudite orbital stability (inverse of phase difference)
                const stabilityFactor = Math.max(0, 1 - Math.abs(phaseDiff) / Math.PI);
                eruditeStabilitySum += stabilityFactor;
                eruditeCount++;
                
                // Store stability factor in the entity for visualization purposes
                erudite.stabilityFactor = stabilityFactor;
                
                // Update erudite phase with Mentor influence
                // Similar to Mentor update but with different parameters
                const velocityComponent = erudite.phaseVelocity * (STABILITY_EMPHASIS + (1 - STABILITY_EMPHASIS) * stabilityFactor);
                const influenceComponent = -attraction * (1 - stabilityFactor * STABILITY_EMPHASIS);
                
                erudite.phase += (velocityComponent + influenceComponent) * deltaTime * simulationState.speed;
                erudite.phase = normalizePhase(erudite.phase);
                
                // Update rotation - Erudites also rotate on their axes
                erudite.rotationAngle = (erudite.rotationAngle || 0) + (erudite.phaseVelocity * 1.5 * deltaTime * simulationState.speed);
                
                // Update Erudite position relative to parent Mentor
                erudite.orbitCenter.x = parent.x;
                erudite.orbitCenter.y = parent.y;
            });
            
            // Update orbital stability metrics
            if (mentorCount > 0) {
                simulationState.orbitalStability.mentors = Math.round((mentorStabilitySum / mentorCount) * 100);
            }
            
            if (eruditeCount > 0) {
                simulationState.orbitalStability.erudites = Math.round((eruditeStabilitySum / eruditeCount) * 100);
            }
            
            // Check if we've achieved stable revolution (high stability values)
            const averageStability = (simulationState.orbitalStability.mentors + simulationState.orbitalStability.erudites) / 2;
            simulationState.stableRevolution = averageStability >= 85; // Consider stable when > 85%
            
            // Calculate radial resonance
            calculateRadialResonance();
            
            // Calculate parameter activation based on Elder phase
            calculateParameterActivation(elder.phase);
            
            // Update orbital dynamics display
            updateOrbitalDynamicsDisplay();
        }
        
        function calculateRadialResonance() {
            // Radial resonance is determined by the harmonic relationship between orbital radii
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            const erudites = simulationState.entities.filter(e => e.type === "erudite");
            
            if (mentors.length === 0) {
                simulationState.radialResonance = 0;
                return;
            }
            
            // Calculate resonance based on mentor orbit ratios
            // Ideal ratios are integer multiples or simple fractions (1:2, 2:3, 3:4, etc.)
            let resonanceSum = 0;
            if (mentors.length > 1) {
                for (let i = 0; i < mentors.length - 1; i++) {
                    for (let j = i + 1; j < mentors.length; j++) {
                        const ratio = mentors[i].orbitRadius / mentors[j].orbitRadius;
                        const normalizedRatio = ratio > 1 ? 1 / ratio : ratio;
                        
                        // Calculate how close this is to a "perfect" ratio (1/2, 2/3, 3/4, etc.)
                        // Closer to a perfect ratio = higher resonance
                        const idealRatios = [1, 1/2, 2/3, 3/4, 4/5, 5/6];
                        const closestRatio = idealRatios.reduce((prev, curr) => 
                            Math.abs(curr - normalizedRatio) < Math.abs(prev - normalizedRatio) ? curr : prev
                        );
                        
                        const resonanceFactor = 1 - Math.min(1, Math.abs(normalizedRatio - closestRatio) * 10);
                        resonanceSum += resonanceFactor;
                    }
                }
                
                const pairCount = (mentors.length * (mentors.length - 1)) / 2;
                const mentorResonance = resonanceSum / pairCount;
                
                // Further adjust based on erudite orbital relationships
                let eruditeResonanceFactor = 1;
                if (erudites.length > 0) {
                    // Similar calculation for erudites could be added here
                    // For now we'll use a simplified approach
                    eruditeResonanceFactor = 0.5 + (Math.min(erudites.length, 5) / 10);
                }
                
                // Combine mentor and erudite resonance factors
                simulationState.radialResonance = Math.round(mentorResonance * eruditeResonanceFactor * 100);
            } else {
                // With just one mentor, resonance is determined by Elder-Mentor harmony
                const elder = simulationState.entities.find(e => e.type === "elder");
                const mentor = mentors[0];
                
                const phaseDiff = calculatePhaseDifference(elder.phase, mentor.phase);
                const normalizedDiff = Math.abs(phaseDiff) / Math.PI;
                
                simulationState.radialResonance = Math.round((1 - normalizedDiff) * 100);
            }
        }
        
        function updateOrbitalDynamicsDisplay() {
            // Update orbital dynamics display
            document.getElementById("mentor-stability").textContent = simulationState.orbitalStability.mentors;
            document.getElementById("erudite-stability").textContent = simulationState.orbitalStability.erudites;
            document.getElementById("radial-resonance").textContent = simulationState.radialResonance;
            
            // Calculate system convergence state based on stability and resonance
            let convergenceState = "Forming";
            const averageStability = (simulationState.orbitalStability.mentors + simulationState.orbitalStability.erudites) / 2;
            
            // Track if we have achieved stable revolution (high stability values)
            const stableRevolution = averageStability >= 85;
            simulationState.stableRevolution = stableRevolution;
            
            // Calculate rotation stability - the variance in rotation speeds relative to orbital period
            // For each entity, calculate the ratio of rotation speed to orbital period
            let rotationStability = 0;
            
            // Only calculate for non-Elder entities that have completed at least one orbit
            const rotatingEntities = simulationState.entities.filter(e => 
                e.type !== "elder" && e.rotationAngle && e.rotationAngle > Math.PI * 2);
                
            if (rotatingEntities.length > 0) {
                const idealRatio = 1.0; // One rotation per orbit is ideal
                let ratioSum = 0;
                
                rotatingEntities.forEach(entity => {
                    // Calculate rotation to orbit ratio
                    const orbitalPeriod = entity.orbitalPeriod || 100;
                    const rotationSpeed = entity.phaseVelocity * (entity.type === "mentor" ? 0.5 : 1.5);
                    const rotationPeriod = 2 * Math.PI / rotationSpeed;
                    const ratio = rotationPeriod / orbitalPeriod;
                    
                    // Store for visualization
                    entity.rotationRatio = ratio;
                    
                    // Calculate how close to ideal
                    const ratioDistance = Math.abs(ratio - idealRatio);
                    const normalizedRatio = Math.max(0, 1 - ratioDistance);
                    ratioSum += normalizedRatio;
                });
                
                rotationStability = Math.round((ratioSum / rotatingEntities.length) * 100);
            }
            
            simulationState.rotationStability = rotationStability;
            document.getElementById("rotation-stability").textContent = rotationStability;
            
            // Determine convergence state using stability, resonance and rotation stability
            if (averageStability > 90 && simulationState.radialResonance > 90 && rotationStability > 90) {
                convergenceState = "Harmonic Convergence";
            } else if (averageStability > 80 && simulationState.radialResonance > 80 && rotationStability > 70) {
                convergenceState = "Stable Heliosystem";
            } else if (averageStability > 65 && simulationState.radialResonance > 65 && rotationStability > 50) {
                convergenceState = "Converging";
            } else if (averageStability > 40 || simulationState.radialResonance > 40 || rotationStability > 30) {
                convergenceState = "Stabilizing";
            }
            
            document.getElementById("system-convergence").textContent = convergenceState;
            
            // Update the revolution stability status
            const revolutionElement = document.getElementById("revolution-stability");
            if (stableRevolution) {
                revolutionElement.textContent = "Achieved";
                revolutionElement.className = "status-good";
            } else {
                revolutionElement.textContent = "Forming";
                revolutionElement.className = "status-pending";
            }
            
            // Update influence lines visualization based on orbital metrics
            updateInfluenceLines();
        }
        
        function updateInfluenceLines() {
            const currentTime = performance.now();
            // Only update influence lines periodically for performance
            if (currentTime - simulationState.lastInfluenceUpdate < 1000) return;
            
            simulationState.lastInfluenceUpdate = currentTime;
            simulationState.influenceLines = [];
            
            const elder = simulationState.entities.find(e => e.type === "elder");
            if (!elder) return;
            
            // Get system stability metrics
            const mentorStability = simulationState.orbitalStability.mentors / 100;
            const eruditeStability = simulationState.orbitalStability.erudites / 100;
            const rotationStability = simulationState.rotationStability / 100;
            const stableRevolution = simulationState.stableRevolution;
            
            // Create influence lines from Elder to each Mentor
            simulationState.entities.filter(e => e.type === "mentor").forEach(mentor => {
                // Calculate intensity based on orbital stability
                const intensity = Math.max(0.1, Math.min(0.8, mentorStability));
                
                // Color intensity for stable vs unstable orbits
                const isStable = mentor.stabilityFactor > 0.8;
                
                // For stable revolutions, use a more solid connection 
                const strokeDasharray = stableRevolution ? "none" : "5,3";
                const lineWidth = stableRevolution ? 2.5 : 1.5;
                
                simulationState.influenceLines.push({
                    id: `elder-${mentor.id}`,
                    sourceX: elder.x,
                    sourceY: elder.y,
                    targetX: mentor.x,
                    targetY: mentor.y,
                    type: 'elder-mentor',
                    intensity: intensity,
                    stable: isStable,
                    strokeDasharray: strokeDasharray,
                    strokeWidth: lineWidth
                });
            });
            
            // Create influence lines from each Mentor to its Erudites
            simulationState.entities.filter(e => e.type === "erudite").forEach(erudite => {
                const mentor = erudite.parent;
                
                // Calculate intensity based on orbital stability
                const intensity = Math.max(0.1, Math.min(0.8, eruditeStability));
                
                // Determine if this erudite has a stable orbit
                const isStable = erudite.stabilityFactor > 0.8;
                
                // For stable revolutions, use a more solid connection
                const strokeDasharray = stableRevolution ? "none" : "3,2";
                const lineWidth = stableRevolution ? 1.5 : 1;
                
                simulationState.influenceLines.push({
                    id: `mentor-${mentor.id}-${erudite.id}`,
                    sourceX: mentor.x,
                    sourceY: mentor.y,
                    targetX: erudite.x,
                    targetY: erudite.y,
                    type: 'mentor-erudite',
                    intensity: intensity,
                    stable: isStable,
                    strokeDasharray: strokeDasharray, 
                    strokeWidth: lineWidth
                });
            });
            
            renderInfluenceLines();
        }
        
        function renderInfluenceLines() {
            const svg = d3.select("#visualization");
            const linesGroup = svg.select(".influence-lines");
            
            // Update lines with the latest data
            const lines = linesGroup.selectAll(".influence-line")
                .data(simulationState.influenceLines, d => d.id);
                
            // Remove old lines
            lines.exit().remove();
            
            // Add new lines
            lines.enter()
                .append("line")
                .attr("class", d => `influence-line ${d.type} ${d.stable ? 'stable' : 'unstable'}`)
                .attr("x1", d => d.sourceX)
                .attr("y1", d => d.sourceY)
                .attr("x2", d => d.targetX)
                .attr("y2", d => d.targetY)
                .attr("stroke", d => {
                    // Determine color based on type and stability
                    if (d.type === "elder-mentor") {
                        return d.stable ? 
                            `rgba(255, 215, 0, ${d.intensity * 1.2})` : // Golden for stable Elder-Mentor
                            `rgba(255, 180, 0, ${d.intensity})`;        // Amber for unstable Elder-Mentor
                    } else {
                        return d.stable ? 
                            `rgba(100, 215, 255, ${d.intensity * 1.2})` : // Bright blue for stable Mentor-Erudite
                            `rgba(100, 180, 255, ${d.intensity})`;        // Softer blue for unstable Mentor-Erudite
                    }
                })
                .attr("stroke-width", d => d.strokeWidth || (1 + d.intensity * 2))
                .attr("stroke-dasharray", d => d.strokeDasharray || "4, 2")
                .attr("opacity", d => d.intensity)
                .style("pointer-events", "none");
                
            // Update existing lines
            lines
                .attr("class", d => `influence-line ${d.type} ${d.stable ? 'stable' : 'unstable'}`)
                .attr("x1", d => d.sourceX)
                .attr("y1", d => d.sourceY)
                .attr("x2", d => d.targetX)
                .attr("y2", d => d.targetY)
                .attr("stroke", d => {
                    // Determine color based on type and stability
                    if (d.type === "elder-mentor") {
                        return d.stable ? 
                            `rgba(255, 215, 0, ${d.intensity * 1.2})` : // Golden for stable Elder-Mentor
                            `rgba(255, 180, 0, ${d.intensity})`;        // Amber for unstable Elder-Mentor
                    } else {
                        return d.stable ? 
                            `rgba(100, 215, 255, ${d.intensity * 1.2})` : // Bright blue for stable Mentor-Erudite
                            `rgba(100, 180, 255, ${d.intensity})`;        // Softer blue for unstable Mentor-Erudite
                    }
                })
                .attr("stroke-width", d => d.strokeWidth || (1 + d.intensity * 2))
                .attr("stroke-dasharray", d => d.strokeDasharray || "4, 2")
                .attr("opacity", d => d.intensity);
        }
        
        function calculateParameterActivation(elderPhase) {
            // Calculate sparsity factor from the system state itself
            const sparsityFactor = calculateSystemDeterminedSparsity();
            
            // Apply syzygy efficiency multiplier if applicable
            const syzygyMultiplier = getSyzygyEfficiencyFactor();
            const effectiveSparsity = sparsityFactor;
            const effectiveParameterCount = config.parameters.totalCount * syzygyMultiplier;
            let activeCount = 0;
            
            // Calculate active parameter count based on determined sparsity
            // Note: With syzygy, we get more "effective parameters" with the same actual parameter count
            // This models how syzygy alignment creates more efficient use of the same parameters
            activeCount = Math.floor(config.parameters.totalCount * effectiveSparsity);
            const effectiveActiveCount = Math.floor(activeCount * syzygyMultiplier);
            
            simulationState.activeParameters = activeCount;
            simulationState.effectiveActiveParameters = effectiveActiveCount;
            
            // Display the effective parameter count with syzygy boost if active
            const displayCount = syzygyMultiplier > 1.0 ? 
                `${activeCount.toLocaleString()} (${effectiveActiveCount.toLocaleString()} effective)` : 
                activeCount.toLocaleString();
                
            document.getElementById("active-count").textContent = displayCount;
            
            // Calculate memory usage (proportional to active parameters)
            const memoryUsage = (activeCount / config.parameters.totalCount) * 
                                config.parameters.peakMemoryMB * 1000;
            document.getElementById("memory-usage").textContent = (memoryUsage / 1000).toFixed(2);
            
            // Update activation history for graph
            simulationState.activationHistory.push(effectiveSparsity);
            simulationState.activationHistory.shift();
            updateActivationGraph();
            
            // Show sparsity factor
            const sparsityDisplay = document.getElementById("sparsity-factor");
            if (sparsityDisplay) {
                sparsityDisplay.textContent = (effectiveSparsity * 100).toFixed(6);
            }
        }
        
        // Syzygy detection and handling functions
        function detectSyzygies() {
            if (!config.parameters.syzygyDetection) return;
            
            const elder = simulationState.entities[0]; // The Elder entity
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            const erudites = simulationState.entities.filter(e => e.type === "erudite");
            
            // Clear previous syzygies
            simulationState.activeSyzygies = [];
            
            // Check for alignments between Elder, Mentors, and Erudites
            mentors.forEach(mentor => {
                const mentorErudites = erudites.filter(e => e.parent === mentor);
                
                mentorErudites.forEach(erudite => {
                    // Calculate vectors for alignment checking
                    const v1 = {
                        x: mentor.x - elder.x,
                        y: mentor.y - elder.y
                    };
                    
                    const v2 = {
                        x: erudite.x - mentor.x,
                        y: erudite.y - mentor.y
                    };
                    
                    // Normalize vectors
                    const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                    const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                    
                    if (mag1 === 0 || mag2 === 0) return; // Skip if any magnitude is zero
                    
                    const n1 = { x: v1.x / mag1, y: v1.y / mag1 };
                    const n2 = { x: v2.x / mag2, y: v2.y / mag2 };
                    
                    // Calculate dot product for alignment check
                    const dotProduct = n1.x * n2.x + n1.y * n2.y;
                    
                    // Angle between vectors in radians
                    const angle = Math.acos(Math.min(Math.max(dotProduct, -1), 1));
                    
                    // Check if the angle is close to 0 or π (aligned or anti-aligned)
                    const isAligned = angle < config.parameters.syzygyAngleTolerance || 
                                      Math.abs(angle - Math.PI) < config.parameters.syzygyAngleTolerance;
                    
                    if (isAligned) {
                        const syzygyId = `${mentor.id}-${erudite.id}`;
                        
                        // Add to active syzygies
                        simulationState.activeSyzygies.push({
                            id: syzygyId,
                            elder: elder,
                            mentor: mentor,
                            erudite: erudite,
                            time: Date.now(),
                            isAntiAligned: angle > Math.PI / 2
                        });
                        
                        // Update count for this pair
                        if (!simulationState.syzygyCounts[syzygyId]) {
                            simulationState.syzygyCounts[syzygyId] = 0;
                        }
                        simulationState.syzygyCounts[syzygyId]++;
                        
                        // Record timestamp of most recent syzygy
                        simulationState.lastSyzygyTime = Date.now();
                        
                        // Add to history (limit to 10 most recent)
                        simulationState.syzygyHistory.unshift({
                            id: syzygyId,
                            mentorDomain: mentor.domain,
                            eruditeId: erudite.id,
                            time: Date.now()
                        });
                        
                        if (simulationState.syzygyHistory.length > 10) {
                            simulationState.syzygyHistory.pop();
                        }
                    }
                });
            });
            
            // Update the visualization
            updateSyzygyVisuals();
        }
        
        function updateSyzygyVisuals() {
            const svg = d3.select("#visualization");
            
            // Update syzygy lines
            const syzygyLines = svg.select(".syzygy-lines").selectAll(".syzygy-line")
                .data(simulationState.activeSyzygies, d => d.id);
            
            // Remove old lines
            syzygyLines.exit().remove();
            
            // Add new lines
            syzygyLines.enter()
                .append("path")
                .attr("class", "syzygy-line")
                .merge(syzygyLines)
                .attr("d", d => {
                    // Draw line from Elder through Mentor to Erudite
                    return `M ${d.elder.x} ${d.elder.y} L ${d.mentor.x} ${d.mentor.y} L ${d.erudite.x} ${d.erudite.y}`;
                });
                
            // Update UI elements
            document.getElementById("syzygy-count").textContent = simulationState.activeSyzygies.length;
            
            // Update the latest syzygy info
            if (simulationState.syzygyHistory.length > 0) {
                const latest = simulationState.syzygyHistory[0];
                document.getElementById("syzygy-latest").textContent = `${latest.mentorDomain}`;
            } else {
                document.getElementById("syzygy-latest").textContent = "None";
            }
            
            // Calculate efficiency boost
            const syzygyBoost = getSyzygyEfficiencyFactor();
            document.getElementById("syzygy-efficiency").textContent = syzygyBoost.toFixed(2);
            
            // Update indicator
            const indicator = document.getElementById("syzygy-indicator");
            if (simulationState.activeSyzygies.length > 0) {
                indicator.className = "syzygy-active";
            } else {
                indicator.className = "syzygy-inactive";
            }
        }
        
        function getSyzygyEfficiencyFactor() {
            if (!config.parameters.syzygyDetection || simulationState.activeSyzygies.length === 0) {
                return 1.0;
            }
            
            // Calculate efficiency boost based on number of active syzygies
            // More syzygies = higher efficiency (up to a cap)
            const maxBoost = config.parameters.syzygyBoostFactor;
            const saturationPoint = 10; // Maximum number of syzygies for full boost
            
            return 1.0 + (Math.min(simulationState.activeSyzygies.length, saturationPoint) / saturationPoint) * (maxBoost - 1.0);
        }
        
        function calculateSystemDeterminedSparsity() {
            // This function calculates the sparsity factor from the system's state
            // rather than using a predetermined value
            
            // Get the Elder entity
            const elder = simulationState.entities[0];
            const mentors = simulationState.entities.filter(e => e.type === "mentor");
            
            // Base sparsity factor from config
            let baseFactor = config.parameters.sparsityBase;
            
            // Phase concentration factor - measures how concentrated the Mentors
            // are around the Elder in phase space
            let phaseConcentrationSum = 0;
            let phaseConcentrationCount = 0;
            
            mentors.forEach(mentor => {
                // Calculate phase difference between Mentor and Elder
                const phaseDiff = Math.abs(calculatePhaseDifference(mentor.phase, elder.phase));
                
                // Normalize to [0, 1] where 0 means perfect alignment and 1 means maximum difference
                const normalizedDiff = phaseDiff / Math.PI;
                
                // Inverse relationship - closer phases mean higher contribution to sparsity
                const contributionFactor = Math.exp(-5 * normalizedDiff);
                
                phaseConcentrationSum += contributionFactor;
                phaseConcentrationCount++;
            });
            
            // Average phase concentration factor (0 to 1)
            const avgPhaseConcentration = phaseConcentrationCount > 0 ? 
                phaseConcentrationSum / phaseConcentrationCount : 0;
                
            // Orbital harmony factor - measures the regularity of orbital positions
            // Higher harmony means more regular spacing, which reduces sparsity
            let orbitalHarmonyFactor = 0;
            
            // Count Mentors in each phase quadrant
            const quadrants = [0, 0, 0, 0];
            mentors.forEach(mentor => {
                const quadrant = Math.floor((mentor.phase / (Math.PI * 2)) * 4) % 4;
                quadrants[quadrant]++;
            });
            
            // Calculate variance in quadrant distribution
            const avgQuadrantCount = mentors.length / 4;
            let quadrantVariance = 0;
            
            quadrants.forEach(count => {
                quadrantVariance += Math.pow(count - avgQuadrantCount, 2);
            });
            
            quadrantVariance /= 4;
            
            // Normalize to [0, 1] where 0 means perfect distribution (low variance)
            // and 1 means highly imbalanced (high variance)
            const maxPossibleVariance = Math.pow(mentors.length, 2) / 4;
            orbitalHarmonyFactor = 1 - (quadrantVariance / maxPossibleVariance);
            
            // Dynamic phase tolerance - decreases with higher concentration and harmony
            let phaseTolerance = config.parameters.phaseToleranceBase;
            
            if (config.parameters.adaptiveFactors) {
                // Phase tolerance decreases when concentration is high (more selective)
                // but increases when harmony is high (more inclusive of structured patterns)
                phaseTolerance *= (0.5 + 0.5 * (1 - avgPhaseConcentration)) * (0.5 + 0.5 * orbitalHarmonyFactor);
            }
            
            // System state-determined sparsity factor
            // Base factor * adaptive modulation based on concentration and harmony
            let sparsityFactor = baseFactor;
            
            if (config.parameters.adaptiveFactors) {
                // Higher phase concentration leads to lower sparsity (more selective)
                // Higher orbital harmony leads to higher sparsity (more inclusive)
                sparsityFactor *= (0.4 + 0.6 * (1 - avgPhaseConcentration)) * (0.4 + 0.6 * orbitalHarmonyFactor);
                
                // Add some intentional variability based on Elder phase
                // This creates patterns in memory usage over time
                const cyclicalComponent = 0.4 + 0.6 * (0.5 + 0.5 * Math.sin(elder.phase * 3));
                sparsityFactor *= cyclicalComponent;
            }
            
            // Ensure sparsity stays within reasonable bounds
            sparsityFactor = Math.max(baseFactor * 0.1, Math.min(baseFactor * 10, sparsityFactor));
            
            return sparsityFactor;
        }
        
        function createActivationGraph() {
            const graphContainer = document.getElementById("activation-graph");
            const svg = d3.select(graphContainer).append("svg")
                .attr("width", "100%")
                .attr("height", "100%");
                
            // Add a path for the activation curve
            svg.append("path")
                .attr("class", "activation-path")
                .attr("fill", "none")
                .attr("stroke", "#ffcc00")
                .attr("stroke-width", 2);
                
            // Add grid lines
            svg.append("line")
                .attr("x1", 0)
                .attr("x2", "100%")
                .attr("y1", "50%")
                .attr("y2", "50%")
                .attr("stroke", "#334466")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "3,3");
        }
        
        function updateActivationGraph() {
            const svg = d3.select("#activation-graph svg");
            const width = svg.node().clientWidth;
            const height = svg.node().clientHeight;
            
            const x = d3.scaleLinear()
                .domain([0, simulationState.activationHistory.length - 1])
                .range([0, width]);
                
            const y = d3.scaleLinear()
                .domain([0, Math.max(0.001, d3.max(simulationState.activationHistory) * 1.2)])
                .range([height, 0]);
                
            const line = d3.line()
                .x((d, i) => x(i))
                .y(d => y(d))
                .curve(d3.curveBasis);
                
            svg.select(".activation-path")
                .attr("d", line(simulationState.activationHistory));
        }
        
        let lastTimestamp = 0;
        function animate(timestamp) {
            if (lastTimestamp === 0) lastTimestamp = timestamp;
            const deltaTime = (timestamp - lastTimestamp) / 1000; // in seconds
            lastTimestamp = timestamp;
            
            if (simulationState.running) {
                updatePhases(deltaTime);
                updateEntitiesPosition();
                updateGlowEffect();
                
                // Detect and update syzygies
                if (config.parameters.syzygyDetection) {
                    detectSyzygies();
                }
                
                // Update memory fields positions
                updateMemoryFields();
                
                // Update gravitational waves
                updateGravitationalWaves(deltaTime);
                
                // Emit new gravitational waves occasionally
                emitGravitationalWave(timestamp);
                
                // Show stable revolution effect if achieved
                if (simulationState.stableRevolution) {
                    showStableRevolutionEffect(timestamp);
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function updateGlowEffect() {
            // Pulsating glow effect for Elder
            const elder = simulationState.entities[0];
            const pulseFactor = 1.6 + 0.4 * Math.sin(Date.now() / 1000);
            
            // For stable revolution, use a different color and larger glow
            if (simulationState.stableRevolution) {
                d3.select(".elder-glow")
                    .attr("r", elder.radius * (pulseFactor + 0.3))
                    .attr("opacity", 0.15 + 0.15 * Math.sin(Date.now() / 500))
                    .attr("stroke", "rgba(120, 255, 120, 0.6)") // Green glow for stable system
                    .attr("stroke-width", 15);
            } else {
                d3.select(".elder-glow")
                    .attr("r", elder.radius * pulseFactor)
                    .attr("opacity", 0.1 + 0.1 * Math.sin(Date.now() / 500))
                    .attr("stroke", elder.color)
                    .attr("stroke-width", 10);
            }
        }
        
        // Function to display visual effects when stable revolution is achieved
        function showStableRevolutionEffect(timestamp) {
            const svg = d3.select("#visualization");
            
            // Check if we're already showing the effect
            if (svg.select(".stable-revolution-effect").size() > 0) {
                return;
            }
            
            // Get the Elder entity
            const elder = simulationState.entities[0];
            
            // Create orbital harmony indicator
            const harmonyGroup = svg.append("g")
                .attr("class", "stable-revolution-effect")
                .style("pointer-events", "none");
            
            // Add a series of concentric circles to indicate orbital harmony
            const harmonicRings = 3;
            const baseRadius = elder.radius * 3;
            const maxOpacity = 0.2;
            
            for (let i = 0; i < harmonicRings; i++) {
                // Create orbital harmony circles
                const radius = baseRadius + (i * elder.radius * 2);
                
                harmonyGroup.append("circle")
                    .attr("cx", elder.x)
                    .attr("cy", elder.y)
                    .attr("r", radius)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(100, 255, 150, 0.6)")
                    .attr("stroke-width", 3)
                    .attr("opacity", maxOpacity * (1 - i / harmonicRings))
                    .attr("stroke-dasharray", "5, 5")
                    .classed("harmony-ring", true);
            }
            
            // Add circular wave effects that propagate outward
            const emitHarmonyWave = () => {
                const waveRadius = elder.radius * 2;
                
                const wave = harmonyGroup.append("circle")
                    .attr("cx", elder.x)
                    .attr("cy", elder.y)
                    .attr("r", waveRadius)
                    .attr("fill", "none")
                    .attr("stroke", "rgba(180, 255, 180, 0.8)")
                    .attr("stroke-width", 2)
                    .attr("opacity", 0.6);
                    
                // Animate the wave outward and fade it
                wave.transition()
                    .duration(5000)  // 5 seconds
                    .attr("r", waveRadius * 5)
                    .attr("opacity", 0)
                    .on("end", function() {
                        d3.select(this).remove();
                    });
            };
            
            // Emit harmony waves periodically
            simulationState.harmonyWaveInterval = setInterval(emitHarmonyWave, 10000);
            
            // Emit initial wave
            emitHarmonyWave();
            
            // Update the orbital harmonics periodically
            const updateOrbitalHarmonics = () => {
                d3.selectAll(".harmony-ring")
                    .attr("cx", elder.x)
                    .attr("cy", elder.y);
            };
            
            simulationState.orbitalHarmonicsInterval = setInterval(updateOrbitalHarmonics, 100);
        }
        
        function showEntityInfo(event, d) {
            simulationState.selectedEntity = d;
            
            const detailsDiv = document.getElementById("entity-details");
            
            // Build entity-specific information
            let entityHtml = `
                <div>
                    <strong>Type:</strong> ${capitalize(d.type)}
                </div>
                <div>
                    <strong>Domain:</strong> ${d.domain}
                </div>
                <div>
                    <strong>Phase:</strong> ${d.phase.toFixed(3)}
                </div>
            `;
            
            // Add orbital information for non-Elder entities
            if (d.type !== "elder") {
                // Calculate orbital period in frames
                const orbitalPeriod = d.orbitalPeriod || Math.round(2 * Math.PI / d.phaseVelocity);
                
                // Format resonance factor if available
                const resonanceInfo = d.resonanceFactor ? 
                    `<div><strong>Resonance Ratio:</strong> ${d.resonanceFactor.toFixed(3)}</div>` : '';
                
                // Format stability if calculated
                const stabilityInfo = d.stabilityFactor !== undefined ? 
                    `<div><strong>Orbital Stability:</strong> ${Math.round(d.stabilityFactor * 100)}%</div>` : '';
                
                // Calculate rotation information
                let rotationInfo = '';
                if (d.rotationAngle !== undefined) {
                    const rotationVelocity = d.type === "mentor" ? 
                        d.phaseVelocity * 0.5 : d.phaseVelocity * 1.5;
                    const rotationPeriod = Math.round(2 * Math.PI / rotationVelocity);
                    
                    rotationInfo = `
                        <div><strong>Rotation Period:</strong> ${rotationPeriod} frames</div>
                        <div><strong>Orbital Period:</strong> ${orbitalPeriod} frames</div>
                    `;
                    
                    // Add rotation to orbit ratio if calculated
                    if (d.rotationRatio !== undefined) {
                        const rotationQuality = d.rotationRatio > 0.9 && d.rotationRatio < 1.1 ? 
                            "Stable" : "Developing";
                        rotationInfo += `
                            <div><strong>Rotation Ratio:</strong> ${d.rotationRatio.toFixed(2)}</div>
                            <div><strong>Rotation Status:</strong> <span style="color: ${d.rotationRatio > 0.9 && d.rotationRatio < 1.1 ? '#88ff88' : '#ffcc00'}">${rotationQuality}</span></div>
                        `;
                    }
                }
                
                entityHtml += resonanceInfo + stabilityInfo + rotationInfo;
            } else {
                // Elder-specific information
                entityHtml += `
                    <div><strong>Role:</strong> Provides hierarchical guidance to Mentors</div>
                    <div><strong>Status:</strong> ${simulationState.stableRevolution ? 
                        '<span style="color: #88ff88">Stable Heliosystem</span>' : 
                        '<span style="color: #ffcc00">Forming Heliosystem</span>'}
                    </div>
                `;
            }
            
            // Add description as the last item
            entityHtml += `<div><strong>Description:</strong> ${d.description}</div>`;
            
            detailsDiv.innerHTML = entityHtml;
            
            // Highlight the entity
            d3.select(this).select("circle")
                .attr("stroke", "#ffcc00")
                .attr("stroke-width", 3);
        }
        
        function hideEntityInfo() {
            simulationState.selectedEntity = null;
            
            // Reset entity highlight
            d3.select(this).select("circle")
                .attr("stroke", "#ffffff")
                .attr("stroke-width", 2);
        }
        
        // Helper functions
        function normalizePhase(phase) {
            while (phase >= Math.PI * 2) phase -= Math.PI * 2;
            while (phase < 0) phase += Math.PI * 2;
            return phase;
        }
        
        function calculatePhaseDifference(phase1, phase2) {
            let diff = phase2 - phase1;
            
            // Normalize to [-π, π]
            while (diff > Math.PI) diff -= Math.PI * 2;
            while (diff < -Math.PI) diff += Math.PI * 2;
            
            return diff;
        }
        
        function getMentorDomain(index) {
            const domains = [
                "Audio Processing", "Visual Analysis", "Semantic Understanding", 
                "Temporal Patterns", "Spatial Relations", "Harmonic Structures",
                "Rhythmic Patterns", "Timbral Analysis", "Melodic Structures",
                "Dynamic Patterns", "Textural Analysis", "Formal Structures",
                "Phonetic Analysis", "Syntactic Structures", "Semantic Networks",
                "Pragmatic Context", "Emotional Content", "Narrative Flow",
                "Visual Textures", "Color Relationships", "Spatial Composition",
                "Temporal Dynamics", "Cross-modal Binding", "Feature Extraction",
                "Statistical Patterns", "Contextual Relations", "Environmental Sounds",
                "Speech Recognition", "Musical Genres", "Cultural Contexts",
                "Acoustic Properties", "Auditory Scene Analysis"
            ];
            
            return domains[index % domains.length];
        }
        
        function getEruditeTask(mentorDomain, index) {
            const audioTasks = [
                "Onset Detection", "Pitch Tracking", "Timbre Classification", 
                "Beat Detection", "Harmonic Analysis", "Envelope Tracking",
                "Transient Detection", "Spectral Analysis", "Dynamic Processing"
            ];
            
            const visualTasks = [
                "Edge Detection", "Object Recognition", "Motion Tracking",
                "Color Analysis", "Texture Classification", "Spatial Composition",
                "Depth Estimation", "Form Recognition", "Illumination Analysis"
            ];
            
            const semanticTasks = [
                "Word Sense", "Entity Recognition", "Relation Extraction",
                "Sentiment Analysis", "Topic Classification", "Contextual Mapping",
                "Metaphor Detection", "Narrative Structure", "Semantic Roles"
            ];
            
            if (mentorDomain.includes("Audio") || mentorDomain.includes("Harmon") || 
                mentorDomain.includes("Rhythm") || mentorDomain.includes("Timb")) {
                return audioTasks[index % audioTasks.length];
            } 
            else if (mentorDomain.includes("Visual") || mentorDomain.includes("Color") || 
                    mentorDomain.includes("Spatial")) {
                return visualTasks[index % visualTasks.length];
            }
            else {
                return semanticTasks[index % semanticTasks.length];
            }
        }
        
        function toggleSimulation() {
            simulationState.running = !simulationState.running;
            document.getElementById("play-pause").textContent = 
                simulationState.running ? "Pause" : "Play";
        }
        
        function resetSimulation() {
            // Clear any harmony effect intervals
            if (simulationState.harmonyWaveInterval) {
                clearInterval(simulationState.harmonyWaveInterval);
                simulationState.harmonyWaveInterval = null;
            }
            
            if (simulationState.orbitalHarmonicsInterval) {
                clearInterval(simulationState.orbitalHarmonicsInterval);
                simulationState.orbitalHarmonicsInterval = null;
            }
            
            // Remove stable revolution effects
            d3.select(".stable-revolution-effect").remove();
            
            // Reset the phase and recreate entities
            simulationState.elderPhase = config.phases.initElderPhase;
            const center = { 
                x: document.querySelector(".container").clientWidth / 2, 
                y: document.querySelector(".container").clientHeight / 2 
            };
            
            // Reset stability tracking
            simulationState.orbitalStability = {
                mentors: 0,
                erudites: 0
            };
            simulationState.radialResonance = 0;
            simulationState.rotationStability = 0;
            simulationState.stableRevolution = false;
            
            // Reset the simulation start time
            simulationState.startTime = performance.now();
            
            // Recreate all entities
            createEntities(center);
        }
        
        function updateSpeed(event) {
            simulationState.speed = parseFloat(event.target.value);
        }
        
        function capitalize(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }
        
        // Initialize the visualization when the page loads
        window.addEventListener("load", init);
        
        // Handle window resize
        window.addEventListener("resize", function() {
            const svg = d3.select("#visualization");
            const container = document.querySelector(".container");
            svg.attr("width", container.clientWidth)
                .attr("height", container.clientHeight);
                
            // Recenter the system
            const center = { x: container.clientWidth / 2, y: container.clientHeight / 2 };
            simulationState.entities[0].x = center.x;
            simulationState.entities[0].y = center.y;
            simulationState.entities[0].orbitCenter = center;
            
            // Update mentor orbit centers
            simulationState.entities.filter(e => e.type === "mentor").forEach(mentor => {
                mentor.orbitCenter = center;
            });
        });
    </script>
</body>
</html>